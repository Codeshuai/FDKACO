Text,API_1,API_2,Relation (fs/bd/fr/ec/lc/fc/tc)
"String.contentEquals() compares the content of the String with the content of any CharSequence (available since Java 1.5). Saves you from having to turn your StringBuffer, etc into a String before doing the equality comparison, but leaves the null checking to you.",java.lang.string.contentequals,java.lang.string,"[('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"String.contentEquals() compares the content of the String with the content of any CharSequence (available since Java 1.5). Saves you from having to turn your StringBuffer, etc into a String before doing the equality comparison, but leaves the null checking to you.",java.lang.string.contentequals,java.lang.charsequence,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"String.contentEquals() compares the content of the String with the content of any CharSequence (available since Java 1.5). Saves you from having to turn your StringBuffer, etc into a String before doing the equality comparison, but leaves the null checking to you.",java.lang.string.contentequals,java.lang.stringbuffer,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"String.contentEquals() compares the content of the String with the content of any CharSequence (available since Java 1.5). Saves you from having to turn your StringBuffer, etc into a String before doing the equality comparison, but leaves the null checking to you.",java.lang.string,java.lang.charsequence,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"String.contentEquals() compares the content of the String with the content of any CharSequence (available since Java 1.5). Saves you from having to turn your StringBuffer, etc into a String before doing the equality comparison, but leaves the null checking to you.",java.lang.string,java.lang.stringbuffer,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"String.contentEquals() compares the content of the String with the content of any CharSequence (available since Java 1.5). Saves you from having to turn your StringBuffer, etc into a String before doing the equality comparison, but leaves the null checking to you.",java.lang.charsequence,java.lang.stringbuffer,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"To print something different when you call System.out.println(myObject), you must override the toString() method in your own class. Here's a simple example:",java.lang.system.out.println,java.lang.object.tostring,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Before Servlet 3.0 (Dec 2009), the Servlet API didn't natively support multipart/form-data. It supports only the default form enctype of application/x-www-form-urlencoded. The request.getParameter() and consorts would all return null when using multipart form data. This is where the well known Apache Commons FileUpload came into the picture.",javax.servlet.servlet,javax.servlet.servletrequest.getparameter,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"Before Servlet 3.0 (Dec 2009), the Servlet API didn't natively support multipart/form-data. It supports only the default form enctype of application/x-www-form-urlencoded. The request.getParameter() and consorts would all return null when using multipart form data. This is where the well known Apache Commons FileUpload came into the picture.",javax.servlet.servlet,org.apache.commons.fileupload.fileupload,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Before Servlet 3.0 (Dec 2009), the Servlet API didn't natively support multipart/form-data. It supports only the default form enctype of application/x-www-form-urlencoded. The request.getParameter() and consorts would all return null when using multipart form data. This is where the well known Apache Commons FileUpload came into the picture.",javax.servlet.servletrequest.getparameter,org.apache.commons.fileupload.fileupload,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Here's a kickoff example how the doPost() of your UploadServlet may look like when using Apache Commons FileUpload:,javax.servlet.http.httpservlet.dopost,org.apache.commons.fileupload.fileupload,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Note that Glassfish versions older than 3.1.2 had a bug wherein the getParameter() still returns null. If you are targeting such a container and can't upgrade it, then you need to extract the value from getPart() with help of this utility method:",javax.servlet.http.httpservletrequest.getparameter,javax.servlet.http.httpservletrequest.getpart,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"See the relevant JavaDoc.  This approach has the advantage of not needing to explicitly initialize a java.util.Random instance, which can be a source of confusion and error if used inappropriately.",java.lang.javadoc,java.util.random,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Note that the newInstance() call is not needed here. It's just to fix the old and buggy org.gjt.mm.mysql.Driver. Explanation here. If this line throws ClassNotFoundException, then the JAR file containing the JDBC driver class is simply not been placed in the classpath.",java.lang.reflect.array.newinstance,org.gjt.mm.mysql.driver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Note that the newInstance() call is not needed here. It's just to fix the old and buggy org.gjt.mm.mysql.Driver. Explanation here. If this line throws ClassNotFoundException, then the JAR file containing the JDBC driver class is simply not been placed in the classpath.",java.lang.reflect.array.newinstance,java.lang.classnotfoundexception,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Note that the newInstance() call is not needed here. It's just to fix the old and buggy org.gjt.mm.mysql.Driver. Explanation here. If this line throws ClassNotFoundException, then the JAR file containing the JDBC driver class is simply not been placed in the classpath.",org.gjt.mm.mysql.driver,java.lang.classnotfoundexception,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In case you're not on Java 8 yet, or are forced to use java.util.Date, then format the date using SimpleDateFormat using a format pattern matching the input string.",java.lang.string,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In case you're not on Java 8 yet, or are forced to use java.util.Date, then format the date using SimpleDateFormat using a format pattern matching the input string.",java.lang.string,java.text.simpledateformat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"In case you're not on Java 8 yet, or are forced to use java.util.Date, then format the date using SimpleDateFormat using a format pattern matching the input string.",java.util.date,java.text.simpledateformat,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Note the importance of the explicit Locale argument. If you omit it, then it will use the default locale which is not necessarily English as used in the month name of the input string. If the locale doesn't match with the input string, then you would confusingly get a java.text.ParseException even though when the format pattern seems valid.",java.util.locale,java.text.parseexception,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The split("";"", 2)[0] is there to get rid of cookie attributes which are irrelevant for the server side like expires, path, etc. Alternatively, you could also use cookie.substring(0, cookie.indexOf(';')) instead of split().",java.lang.string.split,java.lang.string.substring,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"The split("";"", 2)[0] is there to get rid of cookie attributes which are irrelevant for the server side like expires, path, etc. Alternatively, you could also use cookie.substring(0, cookie.indexOf(';')) instead of split().",java.lang.string.split,java.lang.string.indexof,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"The split("";"", 2)[0] is there to get rid of cookie attributes which are irrelevant for the server side like expires, path, etc. Alternatively, you could also use cookie.substring(0, cookie.indexOf(';')) instead of split().",java.lang.string.substring,java.lang.string.indexof,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"When a client visits the webapp for the first time and/or the HttpSession is obtained for the first time via request.getSession(), the servlet container creates a new HttpSession object, generates a long and unique ID (which you can get by session.getId()), and stores it in the server's memory. The servlet container also sets a Cookie in the Set-Cookie header of the HTTP response with JSESSIONID as its name and the unique session ID as its value.",javax.servlet.http.httpservletrequest.getsession,javax.servlet.http.httpsession.getid,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"When a client visits the webapp for the first time and/or the HttpSession is obtained for the first time via request.getSession(), the servlet container creates a new HttpSession object, generates a long and unique ID (which you can get by session.getId()), and stores it in the server's memory. The servlet container also sets a Cookie in the Set-Cookie header of the HTTP response with JSESSIONID as its name and the unique session ID as its value.",javax.servlet.http.httpservletrequest.getsession,javax.servlet.http.cookie.jsessionid,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"When a client visits the webapp for the first time and/or the HttpSession is obtained for the first time via request.getSession(), the servlet container creates a new HttpSession object, generates a long and unique ID (which you can get by session.getId()), and stores it in the server's memory. The servlet container also sets a Cookie in the Set-Cookie header of the HTTP response with JSESSIONID as its name and the unique session ID as its value.",javax.servlet.http.httpsession.getid,javax.servlet.http.cookie.jsessionid,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.dispatcherservlet,javax.servlet.servlet,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.dispatcherservlet,javax.servlet.servletcontext.addservlet,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.dispatcherservlet,javax.servlet.webapplicationinitializer,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.dispatcherservlet,javax.servlet.servlet.urlmapping,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.dispatcherservlet,javax.servlet.servletspecification,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servlet,javax.servlet.servletcontext.addservlet,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servlet,javax.servlet.webapplicationinitializer,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servlet,javax.servlet.servlet.urlmapping,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servlet,javax.servlet.servletspecification,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servletcontext.addservlet,javax.servlet.webapplicationinitializer,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servletcontext.addservlet,javax.servlet.servlet.urlmapping,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servletcontext.addservlet,javax.servlet.servletspecification,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.webapplicationinitializer,javax.servlet.servlet.urlmapping,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.webapplicationinitializer,javax.servlet.servletspecification,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"A DispatcherServlet is just a typical Java EE Servlet. You register it with your typical &lt;web.xml&gt; &lt;servlet-class&gt; and &lt;servlet-mapping&gt; declaration, or directly through ServletContext#addServlet in a WebApplicationInitializer, or with whatever mechanism Spring boot uses. As such, you must rely on the url mapping logic specified in the Servlet specification, see Chapter 12. See also",javax.servlet.servlet.urlmapping,javax.servlet.servletspecification,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable.",java.lang.object.hashcode,java.lang.object.equals,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"I rarely see anyone using the .hasNext() properly, by testing for the generic .hasNext() to control the event loop, and then using the if(.hasNextXxx()) idiom lets you decide how and what to proceed with your code without having to worry about asking for an int when none is available, thus no exception handling code.",java.util.iterator.hasnext,java.util.iterator.hasnextxxx,"[('yes', 'no', 'yes', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
If you use ChromeDriver driver = new ChromeDriver(); the ChromeDriver instance which will get created through that we will be only able to invoke and act on the methods implemented by ChromeDriver and supported by Chrome Browser only. To act with other browsers we have to specifically create individual objects as below :,org.openqa.selenium.chrome.chromedriver,org.openqa.selenium.chrome.chromebrowser,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"You could probably use Joda-Time as well, but I don't know why you should bother with that (Update 2022; maybe because the entire javax.xml.bind section is missing from Android's javax.xml package).",org.joda.time.joda-time,javax.xml.bind,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"You could probably use Joda-Time as well, but I don't know why you should bother with that (Update 2022; maybe because the entire javax.xml.bind section is missing from Android's javax.xml package).",org.joda.time.joda-time,javax.xml,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"You could probably use Joda-Time as well, but I don't know why you should bother with that (Update 2022; maybe because the entire javax.xml.bind section is missing from Android's javax.xml package).",javax.xml.bind,javax.xml,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"If you are working with a source other than a file, you can use the lines() method in BufferedReader instead.",java.io.bufferedreader.lines,java.io.bufferedreader,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"In this version of the code, the loop thread calls wait(), which puts the thread the sleep. It will not use any CPU cycles while sleeping. After the second thread sets the variable, it calls notifyAll() to wake up any/all threads which were waiting on that object. This is like having the pizza guy ring the doorbell, so you can sit down and rest while waiting, instead of standing awkwardly at the door.",java.lang.object.wait,java.lang.object.notifyall,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
Safe with leading zeros (unlike BigInteger) and with negative byte values (unlike Byte.parseByte),java.math.biginteger,java.lang.byte.parsebyte,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In this case I suggest using the debugger or at least System.out.println and print the length of the String you're trying to parse. If it shows more than the number of digits, try passing stringToParse.trim() to the parsing method. If it won't work, copy the whole string after the : and decode it using online decoder. It'll give you codes of all characters.",java.lang.system.out.println,java.lang.string.trim,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Run java with the option -Djava.net.preferIPv4Stack=true to force java to use IPv4 instead of IPv6. On Linux, this could also be achieved by running (or placing it inside /etc/profile:",java.lang.system,java.net.inetaddress.ipv4,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Run java with the option -Djava.net.preferIPv4Stack=true to force java to use IPv4 instead of IPv6. On Linux, this could also be achieved by running (or placing it inside /etc/profile:",java.lang.system,java.net.inetaddress.ipv6,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Run java with the option -Djava.net.preferIPv4Stack=true to force java to use IPv4 instead of IPv6. On Linux, this could also be achieved by running (or placing it inside /etc/profile:",java.lang.system.java,java.lang.system.linux,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Run java with the option -Djava.net.preferIPv4Stack=true to force java to use IPv4 instead of IPv6. On Linux, this could also be achieved by running (or placing it inside /etc/profile:",java.net.inetaddress.ipv4,java.net.inetaddress.ipv6,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Run java with the option -Djava.net.preferIPv4Stack=true to force java to use IPv4 instead of IPv6. On Linux, this could also be achieved by running (or placing it inside /etc/profile:",java.net.inetaddress.ipv4,java.lang.system.linux,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Run java with the option -Djava.net.preferIPv4Stack=true to force java to use IPv4 instead of IPv6. On Linux, this could also be achieved by running (or placing it inside /etc/profile:",java.net.inetaddress.ipv6,java.lang.system.linux,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The preferred solution is to move the code to the fragment onCreateView(), calling findViewById() on the inflated fragment layout rootView:",android.app.fragment.oncreateview,android.view.view.findviewbyid,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"As far as your original example of List&lt;String&gt; list = new LinkedList(), the compiler generates a warning for that assignment because it must. Consider this:",java.util.list,java.lang.string,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"As far as your original example of List&lt;String&gt; list = new LinkedList(), the compiler generates a warning for that assignment because it must. Consider this:",java.util.list,java.util.linkedlist,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"As far as your original example of List&lt;String&gt; list = new LinkedList(), the compiler generates a warning for that assignment because it must. Consider this:",java.lang.string,java.util.linkedlist,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Of course, if you prefer, you can inline the above into a one-liner:new BigDecimal(value).setScale(places, RoundingMode.HALF_UP).doubleValue()",java.math.bigdecimal,java.math.bigdecimal.setscale,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Of course, if you prefer, you can inline the above into a one-liner:new BigDecimal(value).setScale(places, RoundingMode.HALF_UP).doubleValue()",java.math.bigdecimal,java.math.roundingmode.half_up,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Of course, if you prefer, you can inline the above into a one-liner:new BigDecimal(value).setScale(places, RoundingMode.HALF_UP).doubleValue()",java.math.bigdecimal,java.lang.double.doublevalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Of course, if you prefer, you can inline the above into a one-liner:new BigDecimal(value).setScale(places, RoundingMode.HALF_UP).doubleValue()",java.math.bigdecimal.setscale,java.math.roundingmode.half_up,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Of course, if you prefer, you can inline the above into a one-liner:new BigDecimal(value).setScale(places, RoundingMode.HALF_UP).doubleValue()",java.math.bigdecimal.setscale,java.lang.double.doublevalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Of course, if you prefer, you can inline the above into a one-liner:new BigDecimal(value).setScale(places, RoundingMode.HALF_UP).doubleValue()",java.math.roundingmode.half_up,java.lang.double.doublevalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
123 is a substring of a123b so the find() method outputs true. matches() only 'sees' a123b which is not the same as 123 and thus outputs false.,java.util.regex.matcher.find,java.util.regex.matcher.matches,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Usually, one would call the reduce method using Math.max(int, int) as follows:",java.util.stream.stream.reduce,java.lang.math.max,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
r1 and r2 are just two different objects of classes that implement the Runnable interface and thus implement the run() method.  When you call r1.run() you are executing it in the current thread.,java.lang.runnable,java.lang.runnable.run,"[('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Note there isn't paintComponent(). It's wrong, just use the paint() method,",java.awt.component.paintcomponent,java.awt.component.paint,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement,java.lang.stacktraceelement.getclassname,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement,java.lang.stacktraceelement.getfilename,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement,java.lang.stacktraceelement.getlinenumber,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement,java.lang.stacktraceelement.getmethodname,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement.getclassname,java.lang.stacktraceelement.getfilename,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement.getclassname,java.lang.stacktraceelement.getlinenumber,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement.getclassname,java.lang.stacktraceelement.getmethodname,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement.getfilename,java.lang.stacktraceelement.getlinenumber,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement.getfilename,java.lang.stacktraceelement.getmethodname,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().",java.lang.stacktraceelement.getlinenumber,java.lang.stacktraceelement.getmethodname,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Here's a complete example that may prove helpful. As the sample Map is unmodifiable, I refer you to @mKorbel's example on how to override isCellEditable() and setValueAt().",javax.swing.table.tablemodel.iscelleditable,javax.swing.table.tablemodel.setvalueat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"The first is equivalent to hibernate.show_sql=true legacy property, the second prints the bound parameters among other things.",org.hibernate.cfg.environment.show_sql,java.sql.preparedstatement.setparameter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Invoking dispose() allows the host platform to reclaim memory consumed by the heavyweight peer, but it can't do so until after the WINDOW_CLOSING event is processed on the EventQueue. Even then, gc() is a suggestion.",java.awt.window.dispose,java.awt.event.windowevent.window_closing,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Invoking dispose() allows the host platform to reclaim memory consumed by the heavyweight peer, but it can't do so until after the WINDOW_CLOSING event is processed on the EventQueue. Even then, gc() is a suggestion.",java.awt.window.dispose,java.lang.system.gc,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Invoking dispose() allows the host platform to reclaim memory consumed by the heavyweight peer, but it can't do so until after the WINDOW_CLOSING event is processed on the EventQueue. Even then, gc() is a suggestion.",java.awt.event.windowevent.window_closing,java.lang.system.gc,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
You can use Thread.currentThread().getStackTrace().,java.lang.thread.currentthread,java.lang.thread.getstacktrace,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
yourelement.sendKeys(Keys.RETURN) or .sendKeys(Keys.ENTER) : which is an equivalent of focusing that element and hitting RETURN/ENTER on that element,org.openqa.selenium.webelement.sendkeys,org.openqa.selenium.keys.return,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
yourelement.sendKeys(Keys.RETURN) or .sendKeys(Keys.ENTER) : which is an equivalent of focusing that element and hitting RETURN/ENTER on that element,org.openqa.selenium.webelement.sendkeys,org.openqa.selenium.keys.enter,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
yourelement.sendKeys(Keys.RETURN) or .sendKeys(Keys.ENTER) : which is an equivalent of focusing that element and hitting RETURN/ENTER on that element,org.openqa.selenium.keys.return,org.openqa.selenium.keys.enter,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
It's basically the way that generics are implemented in Java via compiler trickery. The compiled generic code actually just uses java.lang.Object wherever you talk about T (or some other type parameter) - and there's some metadata to tell the compiler that it really is a generic type.,java.lang.reflect.generic,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Class.getResource can take a ""relative"" resource name, which is treated relative to the class's package. Alternatively you can specify an ""absolute"" resource name by using a leading slash. Classloader resource paths are always deemed to be absolute.",java.lang.class.getresource,java.lang.classloader,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
The org.apache.commons.lang.StringEscapeUtils.unescapeJava() given here as another answer is really very little help at all.,org.apache.commons.lang.stringescapeutils.unescapejava,org.apache.commons.lang.stringescapeutils,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.string,java.lang.reflect.method.main,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.string,java.lang.reflect.jni,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.string,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.string,java.lang.java.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.reflect.method.main,java.lang.reflect.jni,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.reflect.method.main,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.reflect.method.main,java.lang.java.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no')]"
"Basically, java.exe is a super simple C application that parses the command line, creates a new String array in the JVM to hold those arguments, parses out the class name that you specified as containing main(), uses JNI calls to find the main() method itself, then invokes the main() method, passing in the newly created string array as a parameter.  This is very, very much like what you do when you use reflection from Java - it just uses confusingly named native function calls instead.",java.lang.reflect.jni,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Yes, you should iterate over 2D boolean array in order to deep copy it. Also look at java.util.Arrays#copyOf methods if you are on Java 6.",java.util.arrays.iterate,java.util.arrays.copyof,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"You do composition by having an instance of another class C as a field of your class, instead of extending C. A good example where composition would've been a lot better than inheritance is java.util.Stack, which currently extends java.util.Vector. This is now considered a blunder. A stack ""is-NOT-a"" vector; you should not be allowed to insert and remove elements arbitrarily. It should've been composition instead.",java.util.stack,java.util.vector,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
See also: How are SSL certificate server names resolved/Can I add alternative names using keytool? If you run into java.security.cert.CertificateException: No name matching localhost found exception.,javax.net.ssl.x509extendedtrustmanager.checkservertrusted,java.security.keystore.setentry,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
See also: How are SSL certificate server names resolved/Can I add alternative names using keytool? If you run into java.security.cert.CertificateException: No name matching localhost found exception.,javax.net.ssl.x509extendedtrustmanager.checkservertrusted,java.security.cert.certificateexception,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
See also: How are SSL certificate server names resolved/Can I add alternative names using keytool? If you run into java.security.cert.CertificateException: No name matching localhost found exception.,java.security.keystore.setentry,java.security.cert.certificateexception,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The binder specifying dependency injection is registered in the constructor of the class, and we also tell the application where to find the REST resources (in your case, MyResource) using the packages() method call.",java.lang.class.constructor,javax.ws.rs.core.application.packages,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"(Public service announcement: NEVER call Optional.get unless you can prove it will never be null; instead use one of the safe methods like orElse or ifPresent.  In retrospect, we should have called get something like getOrElseThrowNoSuchElementException or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of Optional in the first place.  Lesson learned.  (UPDATE: Java 10 has Optional.orElseThrow(), which is semantically equivalent to get(), but whose name is more appropriate.))",java.util.optional.get,java.util.optional.orelse,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"(Public service announcement: NEVER call Optional.get unless you can prove it will never be null; instead use one of the safe methods like orElse or ifPresent.  In retrospect, we should have called get something like getOrElseThrowNoSuchElementException or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of Optional in the first place.  Lesson learned.  (UPDATE: Java 10 has Optional.orElseThrow(), which is semantically equivalent to get(), but whose name is more appropriate.))",java.util.optional.get,java.util.optional.ifpresent,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"(Public service announcement: NEVER call Optional.get unless you can prove it will never be null; instead use one of the safe methods like orElse or ifPresent.  In retrospect, we should have called get something like getOrElseThrowNoSuchElementException or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of Optional in the first place.  Lesson learned.  (UPDATE: Java 10 has Optional.orElseThrow(), which is semantically equivalent to get(), but whose name is more appropriate.))",java.util.optional.get,java.util.optional.orelsethrow,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"(Public service announcement: NEVER call Optional.get unless you can prove it will never be null; instead use one of the safe methods like orElse or ifPresent.  In retrospect, we should have called get something like getOrElseThrowNoSuchElementException or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of Optional in the first place.  Lesson learned.  (UPDATE: Java 10 has Optional.orElseThrow(), which is semantically equivalent to get(), but whose name is more appropriate.))",java.util.optional.orelse,java.util.optional.ifpresent,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"(Public service announcement: NEVER call Optional.get unless you can prove it will never be null; instead use one of the safe methods like orElse or ifPresent.  In retrospect, we should have called get something like getOrElseThrowNoSuchElementException or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of Optional in the first place.  Lesson learned.  (UPDATE: Java 10 has Optional.orElseThrow(), which is semantically equivalent to get(), but whose name is more appropriate.))",java.util.optional.orelse,java.util.optional.orelsethrow,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"(Public service announcement: NEVER call Optional.get unless you can prove it will never be null; instead use one of the safe methods like orElse or ifPresent.  In retrospect, we should have called get something like getOrElseThrowNoSuchElementException or something that made it far clearer that this was a highly dangerous method that undermined the whole purpose of Optional in the first place.  Lesson learned.  (UPDATE: Java 10 has Optional.orElseThrow(), which is semantically equivalent to get(), but whose name is more appropriate.))",java.util.optional.ifpresent,java.util.optional.orelsethrow,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no')]"
"A) @ManyToOne(fetch=FetchType.LAZY) should work just fine. Are you sure it's not being overwritten in the query itself? It's possible to specify join fetch in HQL and / or explicitly set fetch mode via Criteria API which would take precedence over class annotation. If that's not the case and you're still having problems, please post your classes, query and resulting SQL for more to-the-point conversation.",javax.persistence.manytoone,javax.persistence.fetchtype.lazy,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"A) @ManyToOne(fetch=FetchType.LAZY) should work just fine. Are you sure it's not being overwritten in the query itself? It's possible to specify join fetch in HQL and / or explicitly set fetch mode via Criteria API which would take precedence over class annotation. If that's not the case and you're still having problems, please post your classes, query and resulting SQL for more to-the-point conversation.",javax.persistence.manytoone,org.hibernate.query.query,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"A) @ManyToOne(fetch=FetchType.LAZY) should work just fine. Are you sure it's not being overwritten in the query itself? It's possible to specify join fetch in HQL and / or explicitly set fetch mode via Criteria API which would take precedence over class annotation. If that's not the case and you're still having problems, please post your classes, query and resulting SQL for more to-the-point conversation.",javax.persistence.manytoone,org.hibernate.criteria,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"A) @ManyToOne(fetch=FetchType.LAZY) should work just fine. Are you sure it's not being overwritten in the query itself? It's possible to specify join fetch in HQL and / or explicitly set fetch mode via Criteria API which would take precedence over class annotation. If that's not the case and you're still having problems, please post your classes, query and resulting SQL for more to-the-point conversation.",javax.persistence.fetchtype.lazy,org.hibernate.query.query,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"A) @ManyToOne(fetch=FetchType.LAZY) should work just fine. Are you sure it's not being overwritten in the query itself? It's possible to specify join fetch in HQL and / or explicitly set fetch mode via Criteria API which would take precedence over class annotation. If that's not the case and you're still having problems, please post your classes, query and resulting SQL for more to-the-point conversation.",javax.persistence.fetchtype.lazy,org.hibernate.criteria,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"A) @ManyToOne(fetch=FetchType.LAZY) should work just fine. Are you sure it's not being overwritten in the query itself? It's possible to specify join fetch in HQL and / or explicitly set fetch mode via Criteria API which would take precedence over class annotation. If that's not the case and you're still having problems, please post your classes, query and resulting SQL for more to-the-point conversation.",org.hibernate.query.query,org.hibernate.criteria,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Please be aware: It is required to use getEnclosingConstructor() for constructors. During blocks outside of (named) methods, getEnclosingMethod() returns null.",java.lang.class.getenclosingconstructor,java.lang.class.getenclosingmethod,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no')]"
String.split(String regex): Splits this string around matches of the given regular expression.,java.lang.string.split,java.lang.string,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch,java.util.concurrent.countdownlatch.countdown,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch,java.util.concurrent.countdownlatch.await,"[('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch,javax.swing.jlist,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch,javax.swing.jtable.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch.countdown,java.util.concurrent.countdownlatch.await,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch.countdown,javax.swing.jlist,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch.countdown,javax.swing.jtable.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch.await,javax.swing.jlist,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",java.util.concurrent.countdownlatch.await,javax.swing.jtable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As described here, a CountDownLatch works well in this context. In the example below, each worker invokes latch.countDown() on completion, and a Supervisor worker blocks on latch.await() until all tasks complete. For demonstration purposes, the Supervisor updates the labels. Wholesale removal, shown in comments, is technically possible but generally unappealing. Instead, consider a JList or JTable.",javax.swing.jlist,javax.swing.jtable,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"There are subtle differences as to how the fileName you are passing is interpreted. Basically, you have 2 different methods: ClassLoader.getResourceAsStream() and Class.getResourceAsStream(). These two methods will locate the resource differently.",java.lang.classloader.getresourceasstream,java.lang.class.getresourceasstream,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"ClassLoader.getResourceAsStream(path) will consider all paths to be absolute paths. So calling String.class.getClassLoader().getResourceAsStream(""myfile.txt"") and String.class.getClassLoader().getResourceAsStream(""/myfile.txt"") will both look for a file in your classpath at the following location: ./myfile.txt.",java.lang.classloader.getresourceasstream,java.lang.string.class.getclassloader.getresourceasstream,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"if you need the output to be Tue rather than 3 (Days of week are indexed starting at 1 for Sunday, see Calendar.SUNDAY), instead of going through a calendar, just reformat the string:  new SimpleDateFormat(""EE"").format(date) (EE meaning ""day of week, short version"")",java.util.calendar.sunday,java.text.simpledateformat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"if you need the output to be Tue rather than 3 (Days of week are indexed starting at 1 for Sunday, see Calendar.SUNDAY), instead of going through a calendar, just reformat the string:  new SimpleDateFormat(""EE"").format(date) (EE meaning ""day of week, short version"")",java.util.calendar.sunday,java.text.simpledateformat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"if you need the output to be Tue rather than 3 (Days of week are indexed starting at 1 for Sunday, see Calendar.SUNDAY), instead of going through a calendar, just reformat the string:  new SimpleDateFormat(""EE"").format(date) (EE meaning ""day of week, short version"")",java.text.simpledateformat,java.text.simpledateformat,"[('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"if you have your input as string, rather than Date, you should use SimpleDateFormat to parse it: new SimpleDateFormat(""dd/M/yyyy"").parse(dateString)",java.text.simpledateformat,java.text.simpledateformat.parse,"[('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'yes', 'yes')]"
edit: since Java 8 you can now use java.time package instead of joda-time,java.time,org.joda.time,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
Then immediately convert to a LocalDate. You should handle the java.sql objects as briefly as possible. Do all your business logic and other work using only the java.time types.,java.time.localdate,java.sql,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
Then immediately convert to a LocalDate. You should handle the java.sql objects as briefly as possible. Do all your business logic and other work using only the java.time types.,java.time.localdate,java.time,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, &amp; SimpleDateFormat.",java.time,java.util.calendar,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, &amp; SimpleDateFormat.",java.time,java.text.simpledateformat,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, &amp; SimpleDateFormat.",java.util.calendar,java.text.simpledateformat,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Pay close attention to the details. You probably are using an interface when you are only providing the implementation, or try to use a parent class when Dagger only knows about the subclass.@Qualifier or used @Named(""typeA"") with it. To Dagger this is a completely different object! Double check that you actually provide and request the same dependency.",javax.inject.qualifier,javax.inject.named,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Pay close attention to the details. You probably are using an interface when you are only providing the implementation, or try to use a parent class when Dagger only knows about the subclass.@Qualifier or used @Named(""typeA"") with it. To Dagger this is a completely different object! Double check that you actually provide and request the same dependency.",javax.inject.qualifier,dagger.dagger,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Pay close attention to the details. You probably are using an interface when you are only providing the implementation, or try to use a parent class when Dagger only knows about the subclass.@Qualifier or used @Named(""typeA"") with it. To Dagger this is a completely different object! Double check that you actually provide and request the same dependency.",javax.inject.named,dagger.dagger,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Sets the designated parameter to the given java.sql.Timestamp value, using the given Calendar object. The driver uses the Calendar object to construct an SQL TIMESTAMP value, which the driver then sends to the database. With a Calendar object, the driver can calculate the timestamp taking into account a custom time zone. If no Calendar object is specified, the driver uses the default time zone, which is that of the virtual machine running the application.",java.sql.timestamp,java.util.calendar,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Could not find class 'javax.mail.internet.InternetAddress', referenced from method com.my.project.Main.isValidEmailAddress",javax.mail.internet.internetaddress,com.my.project.main.isvalidemailaddress,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"It is recommended now to use list.toArray(new Foo[0]);, not list.toArray(new Foo[list.size()]);.",java.util.list.toarray,java.lang.object.foo,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"StringUtils.join(java.lang.Iterable,char)",org.apache.commons.lang3.stringutils.join,java.lang.iterable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"StringUtils.join(java.lang.Iterable,char)",org.apache.commons.lang3.stringutils.join,char,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"StringUtils.join(java.lang.Iterable,char)",java.lang.iterable,char,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Depends on the SQL type of the field, really. PreparedStatement has setters for all three values, #setDate() being the one for sql.Date, #setTime() for sql.Time and #setTimestamp() for sql.Timestamp.",java.sql.preparedstatement,java.sql.preparedstatement.setdate,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Depends on the SQL type of the field, really. PreparedStatement has setters for all three values, #setDate() being the one for sql.Date, #setTime() for sql.Time and #setTimestamp() for sql.Timestamp.",java.sql.preparedstatement,java.sql.preparedstatement.settime,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Depends on the SQL type of the field, really. PreparedStatement has setters for all three values, #setDate() being the one for sql.Date, #setTime() for sql.Time and #setTimestamp() for sql.Timestamp.",java.sql.preparedstatement,java.sql.preparedstatement.settimestamp,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"Depends on the SQL type of the field, really. PreparedStatement has setters for all three values, #setDate() being the one for sql.Date, #setTime() for sql.Time and #setTimestamp() for sql.Timestamp.",java.sql.preparedstatement.setdate,java.sql.preparedstatement.settime,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Depends on the SQL type of the field, really. PreparedStatement has setters for all three values, #setDate() being the one for sql.Date, #setTime() for sql.Time and #setTimestamp() for sql.Timestamp.",java.sql.preparedstatement.setdate,java.sql.preparedstatement.settimestamp,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Depends on the SQL type of the field, really. PreparedStatement has setters for all three values, #setDate() being the one for sql.Date, #setTime() for sql.Time and #setTimestamp() for sql.Timestamp.",java.sql.preparedstatement.settime,java.sql.preparedstatement.settimestamp,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You can use Files#readAllLines() to get all lines of a text file into a List&lt;String&gt;.,java.nio.file.files.readalllines,java.util.list&lt;string&gt;,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"If you happen to be at Java 8 already, then you can even use Stream API for this, starting with Files#lines().",java.util.stream.stream,java.nio.file.files.lines,"[('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The JceSecurity.isRestricted = false part is all that is needed to use 256-bit ciphers directly; however, without the two other operations, Cipher.getMaxAllowedKeyLength() will still keep reporting 128, and 256-bit TLS cipher suites won't work.",javax.crypto.jcesecurity.isrestricted,javax.crypto.cipher.getmaxallowedkeylength,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"You can now simply do Instant.parse(""2015-04-28T14:23:38.521Z"") and get the correct thing now, especially since you should be using Instant instead of the broken java.util.Date with the most recent versions of Java. ",java.time.instant.parse,java.time.instant,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"You can now simply do Instant.parse(""2015-04-28T14:23:38.521Z"") and get the correct thing now, especially since you should be using Instant instead of the broken java.util.Date with the most recent versions of Java. ",java.time.instant.parse,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"You can now simply do Instant.parse(""2015-04-28T14:23:38.521Z"") and get the correct thing now, especially since you should be using Instant instead of the broken java.util.Date with the most recent versions of Java. ",java.time.instant,java.util.date,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"When you are done with using your Connection, you need to explicitly close it by calling its close() method in order to release any other database resources (cursors, handles, etc.) the connection may be holding on to.",java.sql.connection,java.sql.connection.close,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"We could overload the toString() method of a MyComplexNumber class to have it return the stringified hour of the day. Should the toString() overloading be banned, too? We could sabotage MyComplexNumber.equals to have it return a random value, modify the operands... etc. etc. etc..",java.lang.object.tostring,mycomplexnumber.equals,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"You can, however, have a List&lt;Integer&gt; using the Integer class that wraps the int primitive. Convert your array to a List with the Arrays.asList utility method.",java.util.list,java.lang.integer,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"You can, however, have a List&lt;Integer&gt; using the Integer class that wraps the int primitive. Convert your array to a List with the Arrays.asList utility method.",java.util.list,int,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"You can, however, have a List&lt;Integer&gt; using the Integer class that wraps the int primitive. Convert your array to a List with the Arrays.asList utility method.",java.util.list,java.util.arrays.aslist,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"You can, however, have a List&lt;Integer&gt; using the Integer class that wraps the int primitive. Convert your array to a List with the Arrays.asList utility method.",java.lang.integer,int,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"You can, however, have a List&lt;Integer&gt; using the Integer class that wraps the int primitive. Convert your array to a List with the Arrays.asList utility method.",java.lang.integer,java.util.arrays.aslist,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"You can, however, have a List&lt;Integer&gt; using the Integer class that wraps the int primitive. Convert your array to a List with the Arrays.asList utility method.",int,java.util.arrays.aslist,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
The method java.sql.Date.valueOf(java.lang.String) received a string representing a date in the format yyyy-[m]m-[d]d. e.g.:,java.sql.date.valueof,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"The example below allows one to update a subplot or change a series' visibility independently. Break on configure() to see the effect. Your suggestion to toggle setAutoRange () can be replaced with a single call to configure(); but the effect should be nil, as the data and its combined maximal Range are unchanged.",org.jfree.chart.plot.xyplot.configure,org.jfree.chart.axis.valueaxis.setautorange,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
The AtomicInteger class uses CAS (compare-and-swap) low-level CPU operations (no synchronization needed!) They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully). So when you execute getAndIncrement() it actually runs in a loop (simplified real implementation):,java.util.concurrent.atomic.atomicinteger,java.util.concurrent.atomic.atomicinteger.cas,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
The AtomicInteger class uses CAS (compare-and-swap) low-level CPU operations (no synchronization needed!) They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully). So when you execute getAndIncrement() it actually runs in a loop (simplified real implementation):,java.util.concurrent.atomic.atomicinteger,java.util.concurrent.atomic.atomicinteger.getandincrement,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
The AtomicInteger class uses CAS (compare-and-swap) low-level CPU operations (no synchronization needed!) They allow you to modify a particular variable only if the present value is equal to something else (and is returned successfully). So when you execute getAndIncrement() it actually runs in a loop (simplified real implementation):,java.util.concurrent.atomic.atomicinteger.cas,java.util.concurrent.atomic.atomicinteger.getandincrement,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"If you want to see if the regex matches an input text, use a Pattern, a Matcher and the .find() method of the matcher:",java.util.regex.pattern,java.util.regex.matcher,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"If you want to see if the regex matches an input text, use a Pattern, a Matcher and the .find() method of the matcher:",java.util.regex.pattern,java.util.regex.matcher.find,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"If you want to see if the regex matches an input text, use a Pattern, a Matcher and the .find() method of the matcher:",java.util.regex.matcher,java.util.regex.matcher.find,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Particularly offensive to me is the fact that Stream does not implement Iterable (despite actually having method iterator) and cannot be used in a for-each, only with a forEach(). I recommend casting Streams into Iterables with (Iterable&lt;T&gt;)stream::iterator. A better alternative is to use StreamEx which fixes a number of Stream API problems, including implementing Iterable.",java.util.stream.stream,java.lang.iterable,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Particularly offensive to me is the fact that Stream does not implement Iterable (despite actually having method iterator) and cannot be used in a for-each, only with a forEach(). I recommend casting Streams into Iterables with (Iterable&lt;T&gt;)stream::iterator. A better alternative is to use StreamEx which fixes a number of Stream API problems, including implementing Iterable.",java.util.stream.stream,java.util.stream.stream.foreach,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Particularly offensive to me is the fact that Stream does not implement Iterable (despite actually having method iterator) and cannot be used in a for-each, only with a forEach(). I recommend casting Streams into Iterables with (Iterable&lt;T&gt;)stream::iterator. A better alternative is to use StreamEx which fixes a number of Stream API problems, including implementing Iterable.",java.util.stream.stream,eu.javaspecialists.tjsn.concurrency.interlocker.streamex,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Particularly offensive to me is the fact that Stream does not implement Iterable (despite actually having method iterator) and cannot be used in a for-each, only with a forEach(). I recommend casting Streams into Iterables with (Iterable&lt;T&gt;)stream::iterator. A better alternative is to use StreamEx which fixes a number of Stream API problems, including implementing Iterable.",java.lang.iterable,java.util.stream.stream.foreach,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Particularly offensive to me is the fact that Stream does not implement Iterable (despite actually having method iterator) and cannot be used in a for-each, only with a forEach(). I recommend casting Streams into Iterables with (Iterable&lt;T&gt;)stream::iterator. A better alternative is to use StreamEx which fixes a number of Stream API problems, including implementing Iterable.",java.lang.iterable,eu.javaspecialists.tjsn.concurrency.interlocker.streamex,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Particularly offensive to me is the fact that Stream does not implement Iterable (despite actually having method iterator) and cannot be used in a for-each, only with a forEach(). I recommend casting Streams into Iterables with (Iterable&lt;T&gt;)stream::iterator. A better alternative is to use StreamEx which fixes a number of Stream API problems, including implementing Iterable.",java.util.stream.stream.foreach,eu.javaspecialists.tjsn.concurrency.interlocker.streamex,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Class loaders no longer used can be garbage collected (unless there is a memory leak, as is often the case with using ThreadLocal, JDBC drivers, java.beans, etc).",java.lang.classloader,java.lang.threadlocal,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Class loaders no longer used can be garbage collected (unless there is a memory leak, as is often the case with using ThreadLocal, JDBC drivers, java.beans, etc).",java.lang.classloader,java.sql.driver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Class loaders no longer used can be garbage collected (unless there is a memory leak, as is often the case with using ThreadLocal, JDBC drivers, java.beans, etc).",java.lang.classloader,java.beans,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Class loaders no longer used can be garbage collected (unless there is a memory leak, as is often the case with using ThreadLocal, JDBC drivers, java.beans, etc).",java.lang.threadlocal,java.sql.driver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Class loaders no longer used can be garbage collected (unless there is a memory leak, as is often the case with using ThreadLocal, JDBC drivers, java.beans, etc).",java.lang.threadlocal,java.beans,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Class loaders no longer used can be garbage collected (unless there is a memory leak, as is often the case with using ThreadLocal, JDBC drivers, java.beans, etc).",java.sql.driver,java.beans,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"This means the constructor does not have access to @FXML fields referring to components defined in the .fxml file, while initialize() does have access to them.",java.lang.reflect.constructor,javafx.fxml.initializable.initialize,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"getResourceAsStream returns an InputStream, but obtains an URL under the hood. Alternatively, you could get an URL if that's what you need. getResource() will return an URL",java.lang.class.getresourceasstream,java.lang.class.getresource,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"Since JDK 1.5 Java has had extremely well implemented and robust concurrency tools beyond just locks, they live in java.util.concurrent and a specifically interesting example is the java.util.concurrent.atomic subpackage that contains thread-safe primitives that implement the compare-and-swap operation and can map to actual native hardware-supported versions of these operations.",java.util.concurrent,java.util.concurrent.atomic,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string,java.lang.string.replace,"[('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string,java.lang.string.replacefirst,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string,java.lang.string.replaceall,"[('yes', 'no', 'yes', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string,java.lang.character,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replace,java.lang.string.replacefirst,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replace,java.lang.string.replaceall,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replace,java.lang.character,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replace,java.lang.charsequence,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replacefirst,java.lang.string.replaceall,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replacefirst,java.lang.character,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replacefirst,java.lang.charsequence,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replaceall,java.lang.character,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.string.replaceall,java.lang.charsequence,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In java.lang.String, the replace method either takes a pair of char's or a pair of CharSequence's (of which String is a subclass, so it'll happily take a pair of String's). The replace method will replace all occurrences of a char or CharSequence. On the other hand, the first  String arguments of replaceFirst and replaceAll are regular expressions (regex). Using the wrong function can lead to subtle bugs.",java.lang.character,java.lang.charsequence,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
currentLocale can be obtained from Locale.getDefault() i.e.:,java.util.locale.currentlocale,java.util.locale.getdefault,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Considering the String class' length method returns an int, the maximum length that would be returned by the method would be Integer.MAX_VALUE, which is 2^31 - 1 (or approximately 2 billion.)",java.lang.string.length,java.lang.integer.max_value,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Addendum: Your application lags for 10 seconds on startup. As this is the exact time for which the Controller sleeps, it's surely sleeping on the EDT. An sscce would be dispositive. Instead, do the work on another thread and update the model on the EDT. SwingWorker has a process() method that does so automatically, or you can use invokeLater() as shown below. Until your application is correctly synchronized, there's little hope of getting Apple events to work.",javax.swing.swingworker,javax.swing.swingworker.process,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Addendum: Your application lags for 10 seconds on startup. As this is the exact time for which the Controller sleeps, it's surely sleeping on the EDT. An sscce would be dispositive. Instead, do the work on another thread and update the model on the EDT. SwingWorker has a process() method that does so automatically, or you can use invokeLater() as shown below. Until your application is correctly synchronized, there's little hope of getting Apple events to work.",javax.swing.swingworker,javax.swing.swingutilities.invokelater,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Addendum: Your application lags for 10 seconds on startup. As this is the exact time for which the Controller sleeps, it's surely sleeping on the EDT. An sscce would be dispositive. Instead, do the work on another thread and update the model on the EDT. SwingWorker has a process() method that does so automatically, or you can use invokeLater() as shown below. Until your application is correctly synchronized, there's little hope of getting Apple events to work.",javax.swing.swingworker.process,javax.swing.swingutilities.invokelater,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"However, with your example, I believe it will still fail, since the implementation of getValue() relies on quantity and price, rather than getQuantity() and getPrice(), which is what you've mocked.",java.lang.reflect.method.getvalue,java.lang.reflect.method.getquantity,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"However, with your example, I believe it will still fail, since the implementation of getValue() relies on quantity and price, rather than getQuantity() and getPrice(), which is what you've mocked.",java.lang.reflect.method.getvalue,java.lang.reflect.method.getprice,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"However, with your example, I believe it will still fail, since the implementation of getValue() relies on quantity and price, rather than getQuantity() and getPrice(), which is what you've mocked.",java.lang.reflect.method.getquantity,java.lang.reflect.method.getprice,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"There are also Arrays.equals and Arrays.deepEquals that perform array equality comparison by their elements, among many other array-related utility methods.",java.util.arrays.equals,java.util.arrays.deepequals,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Note that you can add(Integer.valueOf(0)) to any of the above types. however, you CAN'T add(new Object()) to a List&lt;Number&gt; or a List&lt;Serializable&gt;, since that violates the generic type safety rule.",java.util.collection.add,java.lang.integer.valueof,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Note that you can add(Integer.valueOf(0)) to any of the above types. however, you CAN'T add(new Object()) to a List&lt;Number&gt; or a List&lt;Serializable&gt;, since that violates the generic type safety rule.",java.util.collection.add,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Note that you can add(Integer.valueOf(0)) to any of the above types. however, you CAN'T add(new Object()) to a List&lt;Number&gt; or a List&lt;Serializable&gt;, since that violates the generic type safety rule.",java.lang.integer.valueof,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"This does not answer the original question, but as the question is highly ranked and linked for any ContextClassLoader query, I think it is important to answer the related question of when the context class loader should be used. Short answer: never use the context class loader! But set it to getClass().getClassLoader() when you have to call a method that is missing a ClassLoader parameter.",java.lang.thread.getcontextclassloader,java.lang.object.getclass,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"This does not answer the original question, but as the question is highly ranked and linked for any ContextClassLoader query, I think it is important to answer the related question of when the context class loader should be used. Short answer: never use the context class loader! But set it to getClass().getClassLoader() when you have to call a method that is missing a ClassLoader parameter.",java.lang.thread.getcontextclassloader,java.lang.class.getclassloader,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"This does not answer the original question, but as the question is highly ranked and linked for any ContextClassLoader query, I think it is important to answer the related question of when the context class loader should be used. Short answer: never use the context class loader! But set it to getClass().getClassLoader() when you have to call a method that is missing a ClassLoader parameter.",java.lang.object.getclass,java.lang.class.getclassloader,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
where in this case the append method takes the null and then delegates it to String.valueOf().,java.lang.stringbuilder.append,java.lang.string.valueof,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"I see that as of Java 9, Object.finalize() is deprecated! They point us to java.lang.ref.Cleaner and java.lang.ref.PhantomReference as alternatives.",java.lang.object.finalize,java.lang.ref.cleaner,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"I see that as of Java 9, Object.finalize() is deprecated! They point us to java.lang.ref.Cleaner and java.lang.ref.PhantomReference as alternatives.",java.lang.object.finalize,java.lang.ref.phantomreference,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"I see that as of Java 9, Object.finalize() is deprecated! They point us to java.lang.ref.Cleaner and java.lang.ref.PhantomReference as alternatives.",java.lang.ref.cleaner,java.lang.ref.phantomreference,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
You may also want to add the ACCESS_COARSE_LOCATION permission for when GPS isn't available and select your location provider with the getBestProvider() method.,android.manifest.permission.access_coarse_location,android.location.locationmanager.getbestprovider,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"System properties are set on the Java command line using the -Dpropertyname=valueSystem.setProperty(String key, String value)System.getProperties().load() methods.system property you can use System.getProperty(String key) or System.getProperty(String key, String def).",java.lang.system.setproperty,java.lang.system.getproperties,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"System properties are set on the Java command line using the -Dpropertyname=valueSystem.setProperty(String key, String value)System.getProperties().load() methods.system property you can use System.getProperty(String key) or System.getProperty(String key, String def).",java.lang.system.getproperties,java.lang.system.getproperty,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"If your class has a no-arg constructor, you can get a Class object using Class.forName() and use the newInstance() method to create an instance (though beware that this method is often considered evil because it can defeat Java's checked exceptions).",java.lang.class.forname,java.lang.reflect.constructor.newinstance,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The good way to do it is to have the run() of the Thread guarded by a boolean variable and set it to true from the outside when you want to stop it, something like:",java.lang.thread.run,java.lang.boolean,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
getClass().getResource()getClass().getResourceAsStream() which is stream based.,java.lang.object.getclass,java.lang.class.getresourceasstream,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The first thing you have to do is to identify the conditions that you want the methods to wait for. In this case, you will want the put() method to block until there is free space in the store, and you will want the take() method to block until there is some element to return.",java.util.concurrent.blockingqueue.put,java.util.concurrent.blockingqueue.take,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
They can be defined using the @javax.faces.bean.ManagedBean annotation which takes an optional name parameter. This name can be used to reference the bean from JSF pages.,javax.faces.bean.managedbean,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"There's a much better answer than using spliteratorUnknownSize directly, which is both easier and gets a better result.  Iterable has a spliterator() method, so you should just use that to get your spliterator.  In the worst case, it's the same code (the default implementation uses spliteratorUnknownSize), but in the more common case, where your Iterable is already a collection, you'll get a better spliterator, and therefore better stream performance (maybe even good parallelism).  It's also less code:",java.util.spliterator.spliteratorunknownsize,java.lang.iterable.spliterator,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"However the TextView is referenced, it will be filled with the toString() of each object in the array. You can add lists or arrays of custom objects. Override the toString() method of your objects to determine what text will be displayed for the item in the list.",android.widget.textview,java.lang.object.tostring,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Your first matcher anyRequest() is always applied, because the order of matchers is important, see HttpSecurity#authorizeRequests:",org.springframework.security.config.annotation.web.builders.httpsecurity.anyrequest,org.springframework.security.config.annotation.web.builders.httpsecurity.authorizerequests,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"Clearly, notify wakes (any) one thread in the wait set, notifyAll wakes all threads in the waiting set. The following discussion should clear up any doubts. notifyAll should be used most of the time. If you are not sure which to use, then use notifyAll.Please see explanation that follows.",java.lang.object.notify,java.lang.object.notifyall,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is the main reason why Swing's JPasswordField's getText() method is deprecated, and why getPassword() uses character arrays.",javax.swing.jpasswordfield.gettext,javax.swing.jpasswordfield.getpassword,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"multipart/form-data encoded requests are indeed not by default supported by the Servlet API prior to version 3.0. The Servlet API parses the parameters by default using application/x-www-form-urlencoded encoding. When using a different encoding, the request.getParameter() calls will all return null. When you're already on Servlet 3.0 (Glassfish 3, Tomcat 7, etc), then you can use HttpServletRequest#getParts() instead. Also see this blog for extended examples.",javax.servlet.servlet api,javax.servlet.http.httpservletrequest.getparameter,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"multipart/form-data encoded requests are indeed not by default supported by the Servlet API prior to version 3.0. The Servlet API parses the parameters by default using application/x-www-form-urlencoded encoding. When using a different encoding, the request.getParameter() calls will all return null. When you're already on Servlet 3.0 (Glassfish 3, Tomcat 7, etc), then you can use HttpServletRequest#getParts() instead. Also see this blog for extended examples.",javax.servlet.servlet api,javax.servlet.http.httpservletrequest.getparts,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"multipart/form-data encoded requests are indeed not by default supported by the Servlet API prior to version 3.0. The Servlet API parses the parameters by default using application/x-www-form-urlencoded encoding. When using a different encoding, the request.getParameter() calls will all return null. When you're already on Servlet 3.0 (Glassfish 3, Tomcat 7, etc), then you can use HttpServletRequest#getParts() instead. Also see this blog for extended examples.",javax.servlet.http.httpservletrequest.getparameter,javax.servlet.http.httpservletrequest.getparts,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Was puzzled that that header didn't show up on the image at all: it wasn't clipped or something, it wasn't painted at all. The reason for that is .. that at the time of painting the panel to the image, the header is no longer part of the hierarchy. When closing the optionPane, table.removeNotify removes the header. For adding it again, call addNotify, as in this snippet:",java.awt.component.header,java.awt.component.removenotify,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Was puzzled that that header didn't show up on the image at all: it wasn't clipped or something, it wasn't painted at all. The reason for that is .. that at the time of painting the panel to the image, the header is no longer part of the hierarchy. When closing the optionPane, table.removeNotify removes the header. For adding it again, call addNotify, as in this snippet:",java.awt.component.header,java.awt.component.addnotify,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Was puzzled that that header didn't show up on the image at all: it wasn't clipped or something, it wasn't painted at all. The reason for that is .. that at the time of painting the panel to the image, the header is no longer part of the hierarchy. When closing the optionPane, table.removeNotify removes the header. For adding it again, call addNotify, as in this snippet:",java.awt.component.removenotify,java.awt.component.addnotify,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"In order for a View to be created, it must know where to create it and whether it has any children so that it can display. This means that every View has an reference to the Activity (via getContext()). Moreover, every View keeps references to its children (i.e. getChildAt()). Finally, each View keeps a reference to the rendered Bitmap that represents its display.",android.view.view.getcontext,android.view.view.getchildat,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"In order for a View to be created, it must know where to create it and whether it has any children so that it can display. This means that every View has an reference to the Activity (via getContext()). Moreover, every View keeps references to its children (i.e. getChildAt()). Finally, each View keeps a reference to the rendered Bitmap that represents its display.",android.view.view.getcontext,android.graphics.bitmap,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In order for a View to be created, it must know where to create it and whether it has any children so that it can display. This means that every View has an reference to the Activity (via getContext()). Moreover, every View keeps references to its children (i.e. getChildAt()). Finally, each View keeps a reference to the rendered Bitmap that represents its display.",android.view.view.getchildat,android.graphics.bitmap,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The time zone part is important: java.util.Date is always based on UTC. In most cases where I've been interested in a date, that's been a date in a specific time zone. That on its own will force you to use Calendar or Joda Time (unless you want to account for the time zone yourself, which I don't recommend.)",java.util.date,org.joda.time.datetime,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The time zone part is important: java.util.Date is always based on UTC. In most cases where I've been interested in a date, that's been a date in a specific time zone. That on its own will force you to use Calendar or Joda Time (unless you want to account for the time zone yourself, which I don't recommend.)",java.util.calendar,org.joda.time.datetime,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Additionally, if CustomObjectimplements Comparable, then just use Collections.sort(list)",java.lang.comparable,java.util.collections.sort,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The Java programming language is based on the Unicode character set, and several libraries implement the Unicode standard. The primitive data type char in the Java programming language is an unsigned 16-bit integer that can represent a Unicode code point in the range U+0000 to U+FFFF, or the code units of UTF-16. The various types and classes in the Java platform that represent character sequences - char[], implementations of java.lang.CharSequence (such as the String class), and implementations of java.text.CharacterIterator - are UTF-16 sequences.",java.lang.charsequence,java.lang.string,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The Java programming language is based on the Unicode character set, and several libraries implement the Unicode standard. The primitive data type char in the Java programming language is an unsigned 16-bit integer that can represent a Unicode code point in the range U+0000 to U+FFFF, or the code units of UTF-16. The various types and classes in the Java platform that represent character sequences - char[], implementations of java.lang.CharSequence (such as the String class), and implementations of java.text.CharacterIterator - are UTF-16 sequences.",java.lang.charsequence,java.text.characteriterator,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"The Java programming language is based on the Unicode character set, and several libraries implement the Unicode standard. The primitive data type char in the Java programming language is an unsigned 16-bit integer that can represent a Unicode code point in the range U+0000 to U+FFFF, or the code units of UTF-16. The various types and classes in the Java platform that represent character sequences - char[], implementations of java.lang.CharSequence (such as the String class), and implementations of java.text.CharacterIterator - are UTF-16 sequences.",java.lang.string,java.text.characteriterator,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"In this case you must use the iterator.remove() method instead. This occurs equally if you are adding to the collection, in which case there is no general solution. However, the subtype ListIterator can be used if dealing with a list and this has an add() method.",java.util.iterator.remove,java.util.listiterator.add,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Addendum: To color individual items, the API recommends the approach shown here, in which a custom renderer overrides getItemPaint(). Color.getHSBColor() is used to create a full spectrum of colors.",javax.swing.plaf.basic.basictableui.getitempaint,java.awt.color.gethsbcolor,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
Override getPreferredScrollableViewportSize() to customize the size of the table's enclosing JScrollPane.,javax.swing.jtable.getpreferredscrollableviewportsize,javax.swing.jscrollpane,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"That is, a shutdown hook keeps the JVM running until the hook has terminated (returned from the run()-method.",java.lang.runtime.addshutdownhook,java.lang.runnable.run,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"This returns the length of the file in bytes or 0 if the file does not exist. There is no built-in way to get the size of a folder, you are going to have to walk the directory tree recursively (using the listFiles() method of a file object that represents a directory) and accumulate the directory size for yourself:",java.io.file.length,java.io.file.listfiles,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security,java.security.spec.pkcs1encodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security,java.security.security,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security,sun.security.util.dervalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security,java.security.spec.pkcs8encodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security,java.security.spec.pemencodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.spec.pkcs1encodedkeyspec,java.security.security,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.spec.pkcs1encodedkeyspec,sun.security.util.dervalue,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.spec.pkcs1encodedkeyspec,java.security.spec.pkcs8encodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.spec.pkcs1encodedkeyspec,java.security.spec.pemencodedkeyspec,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.security,sun.security.util.dervalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.security,java.security.spec.pkcs8encodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.security,java.security.spec.pemencodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",sun.security.util.dervalue,java.security.spec.pkcs8encodedkeyspec,"[('no', 'no', 'yes', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",sun.security.util.dervalue,java.security.spec.pemencodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This is PKCS#1 format of a private key. Try this code. It doesn't use Bouncy Castle or other third-party crypto providers. Just java.security and sun.security for DER sequece parsing. Also it supports parsing of a private key in PKCS#8 format (PEM file that has a header ""-----BEGIN PRIVATE KEY-----"").",java.security.spec.pkcs8encodedkeyspec,java.security.spec.pemencodedkeyspec,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In the case that your JDBC driver doesn't support it, your best bet is using a statement wrapper which records all calls to setXxx() methods and finally populates a SQL string on toString() based on the recorded information. An existing library which does that is P6Spy. In the meanwhile, post an enhancement request to the development team of your JDBC driver and hope that they'll implement the desired toString() behavior as well.",java.sql.preparedstatement.setxxx,java.lang.object.tostring,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"The performance benefits are of this are huge and only grow as you add more objects to your collection. This is because for an eagerly loaded collection, Hibernate does a ton of behind the scenes checking to ensure that none of your data is out of date. While I do advocate using Hibernate for collections, be aware that there is a performance penalty** for using fetchType.EAGER. However, take our Person object example. Its fairly likely that when we load a Person we will want to know what Roles they perform. I will usually mark this collection as fetchType.EAGER. DON'T REFLEXIVELY MARK YOUR COLLECTION AS fetchType.EAGER SIMPLY TO GET AROUND A LazyInitializationException. Not only is it bad for performance reasons, it generally indicates that you have a design issue. Ask yourself, should this collection actually be an eagerly loaded collection, or am I doing this just to access the collection in this one method. Hibernate has ways around this, that doesn't impact the performance of your operations quite as much. You can use the following code in your Service layer if you want to initialize a lazily loaded collection just for this one call.",javax.persistence.fetchtype.eager,org.hibernate.lazyinitializationexception,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"resource.getFile() expects the resource itself to be available on the file system, i.e. it can't be nested inside a jar file. This is why it works when you run your application in STS (Spring Tool Suite) but doesn't work once you've built your application and run it from the executable jar. Rather than using getFile() to access the resource's contents, I'd recommend using getInputStream() instead. That'll allow you to read the resource's content regardless of where it's located.",java.net.url.getfile,java.net.url.getinputstream,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"However, you seem to be after a List of Strings rather than an array, so the array must be turned into a list by using the Arrays.asList() utility. Just as an FYI you could also do something like so:",java.lang.string,java.util.arrays.aslist,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"This explains why your project runs in the first case, when you don't have a control added to the scene, just the StackPane, that belongs to the javafx.graphics module, but fails with the posted exception when you add the Label, that belongs to the javafx.controls module.",javafx.graphics.stackpane,javafx.controls.label,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Generally, Java 8 streams are not magic. They couldn't speedup already well-implemented things (with, probably, plain iterations or Java 5's for-each statements replaced with Iterable.forEach() and Collection.removeIf() calls). Streams are more about coding convenience and safety. Convenience -- speed tradeoff is working here.",java.lang.iterable.foreach,java.util.collection.removeif,"[('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"It's preferable to use an ArrayDeque instead, which efficiently supports insertion at the front. A small wrinkle is that we can't use the three-arg form of Stream.collect(); it requires the contents of the second arg be merged into the first arg, and there's no ""add-all-at-front"" bulk operation on Deque. Instead, we use addAll() to append the contents of the first arg to the end of the second, and then we return the second. This requires using the Collector.of() factory method.",java.util.arraydeque,java.util.stream.stream.collect,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"It's preferable to use an ArrayDeque instead, which efficiently supports insertion at the front. A small wrinkle is that we can't use the three-arg form of Stream.collect(); it requires the contents of the second arg be merged into the first arg, and there's no ""add-all-at-front"" bulk operation on Deque. Instead, we use addAll() to append the contents of the first arg to the end of the second, and then we return the second. This requires using the Collector.of() factory method.",java.util.arraydeque,java.util.collection.addall,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"It's preferable to use an ArrayDeque instead, which efficiently supports insertion at the front. A small wrinkle is that we can't use the three-arg form of Stream.collect(); it requires the contents of the second arg be merged into the first arg, and there's no ""add-all-at-front"" bulk operation on Deque. Instead, we use addAll() to append the contents of the first arg to the end of the second, and then we return the second. This requires using the Collector.of() factory method.",java.util.arraydeque,java.util.stream.collector.of,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"It's preferable to use an ArrayDeque instead, which efficiently supports insertion at the front. A small wrinkle is that we can't use the three-arg form of Stream.collect(); it requires the contents of the second arg be merged into the first arg, and there's no ""add-all-at-front"" bulk operation on Deque. Instead, we use addAll() to append the contents of the first arg to the end of the second, and then we return the second. This requires using the Collector.of() factory method.",java.util.stream.stream.collect,java.util.collection.addall,"[('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"It's preferable to use an ArrayDeque instead, which efficiently supports insertion at the front. A small wrinkle is that we can't use the three-arg form of Stream.collect(); it requires the contents of the second arg be merged into the first arg, and there's no ""add-all-at-front"" bulk operation on Deque. Instead, we use addAll() to append the contents of the first arg to the end of the second, and then we return the second. This requires using the Collector.of() factory method.",java.util.stream.stream.collect,java.util.stream.collector.of,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"It's preferable to use an ArrayDeque instead, which efficiently supports insertion at the front. A small wrinkle is that we can't use the three-arg form of Stream.collect(); it requires the contents of the second arg be merged into the first arg, and there's no ""add-all-at-front"" bulk operation on Deque. Instead, we use addAll() to append the contents of the first arg to the end of the second, and then we return the second. This requires using the Collector.of() factory method.",java.util.collection.addall,java.util.stream.collector.of,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
There are two good ways to copy array is to use clone and System.arraycopy().,java.lang.object.clone,java.lang.system.arraycopy,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"1. Implement ActionListener in your class, then use jBtnSelection.addActionListener(this);  Later, you'll have to define a menthod, public void actionPerformed(ActionEvent e).  However, doing this for multiple buttons can be confusing, because the actionPerformed method will have to check the source of each event (e.getSource()) to see which button it came from.",java.awt.event.actionlistener,java.awt.component.addactionlistener,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"1. Implement ActionListener in your class, then use jBtnSelection.addActionListener(this);  Later, you'll have to define a menthod, public void actionPerformed(ActionEvent e).  However, doing this for multiple buttons can be confusing, because the actionPerformed method will have to check the source of each event (e.getSource()) to see which button it came from.",java.awt.event.actionlistener,java.awt.awtevent.getsource,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"1. Implement ActionListener in your class, then use jBtnSelection.addActionListener(this);  Later, you'll have to define a menthod, public void actionPerformed(ActionEvent e).  However, doing this for multiple buttons can be confusing, because the actionPerformed method will have to check the source of each event (e.getSource()) to see which button it came from.",java.awt.component.addactionlistener,java.awt.event.actionlistener.actionperformed,"[('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"1. Implement ActionListener in your class, then use jBtnSelection.addActionListener(this);  Later, you'll have to define a menthod, public void actionPerformed(ActionEvent e).  However, doing this for multiple buttons can be confusing, because the actionPerformed method will have to check the source of each event (e.getSource()) to see which button it came from.",java.awt.component.addactionlistener,java.awt.awtevent.getsource,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"1. Implement ActionListener in your class, then use jBtnSelection.addActionListener(this);  Later, you'll have to define a menthod, public void actionPerformed(ActionEvent e).  However, doing this for multiple buttons can be confusing, because the actionPerformed method will have to check the source of each event (e.getSource()) to see which button it came from.",java.awt.event.actionlistener.actionperformed,java.awt.awtevent.getsource,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"In SQL side, there are several standard date and time types, DATE, TIME and TIMESTAMP (at some DB's also called DATETIME), which are represented in JDBC as java.sql.Date, java.sql.Time and java.sql.Timestamp, all subclasses of java.util.Date. The precision is DB dependent, often in milliseconds like Java, but it can also be in seconds.",java.sql.date,java.sql.time,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In SQL side, there are several standard date and time types, DATE, TIME and TIMESTAMP (at some DB's also called DATETIME), which are represented in JDBC as java.sql.Date, java.sql.Time and java.sql.Timestamp, all subclasses of java.util.Date. The precision is DB dependent, often in milliseconds like Java, but it can also be in seconds.",java.sql.date,java.sql.timestamp,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In SQL side, there are several standard date and time types, DATE, TIME and TIMESTAMP (at some DB's also called DATETIME), which are represented in JDBC as java.sql.Date, java.sql.Time and java.sql.Timestamp, all subclasses of java.util.Date. The precision is DB dependent, often in milliseconds like Java, but it can also be in seconds.",java.sql.date,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In SQL side, there are several standard date and time types, DATE, TIME and TIMESTAMP (at some DB's also called DATETIME), which are represented in JDBC as java.sql.Date, java.sql.Time and java.sql.Timestamp, all subclasses of java.util.Date. The precision is DB dependent, often in milliseconds like Java, but it can also be in seconds.",java.sql.time,java.util.date,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In SQL side, there are several standard date and time types, DATE, TIME and TIMESTAMP (at some DB's also called DATETIME), which are represented in JDBC as java.sql.Date, java.sql.Time and java.sql.Timestamp, all subclasses of java.util.Date. The precision is DB dependent, often in milliseconds like Java, but it can also be in seconds.",java.sql.timestamp,java.util.date,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The normal practice to store a timestamp in the DB (thus, java.util.Date in Java side and java.sql.Timestamp in JDBC side) is to use PreparedStatement#setTimestamp().",java.util.date,java.sql.preparedstatement.settimestamp,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The normal practice to store a timestamp in the DB (thus, java.util.Date in Java side and java.sql.Timestamp in JDBC side) is to use PreparedStatement#setTimestamp().",java.sql.timestamp,java.sql.preparedstatement.settimestamp,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Array.asList() wraps an array in the list interface. The list is still backed by the array. Arrays are a fixed size - they don't support adding or removing elements, so the wrapper can't either.",java.util.arrays.aslist,java.util.array,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Array.asList() wraps an array in the list interface. The list is still backed by the array. Arrays are a fixed size - they don't support adding or removing elements, so the wrapper can't either.",java.util.arrays.aslist,java.util.list,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Array.asList() wraps an array in the list interface. The list is still backed by the array. Arrays are a fixed size - they don't support adding or removing elements, so the wrapper can't either.",java.util.array,java.util.list,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You can create Comparators to sort any arbitrary way for any class.String class defines the CASE_INSENSITIVE_ORDER comparator.,java.util.comparator,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
You can create Comparators to sort any arbitrary way for any class.String class defines the CASE_INSENSITIVE_ORDER comparator.,java.util.comparator,java.lang.string.case_insensitive_order,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You can create Comparators to sort any arbitrary way for any class.String class defines the CASE_INSENSITIVE_ORDER comparator.,java.lang.string,java.lang.string.case_insensitive_order,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
You can replace System.in with you own stream by calling System.setIn(InputStream in),java.lang.system.in,java.lang.system.setin,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
You can replace System.in with you own stream by calling System.setIn(InputStream in),java.lang.system.in,java.io.inputstream,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
You can replace System.in with you own stream by calling System.setIn(InputStream in),java.lang.system.setin,java.io.inputstream,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"But I think a work-around for your specific case would be to specify type as 'java.lang.Object', since this should work ok: for serialization, String will be output as is, and for deserialization, it will be deserialized as a Map. Actually you might want to have separate getter/setter if so; getter would return String for serialization (and needs @JsonRawValue); and setter would take either Map or Object. You could re-encode it to a String if that makes sense.",java.lang.object,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"But I think a work-around for your specific case would be to specify type as 'java.lang.Object', since this should work ok: for serialization, String will be output as is, and for deserialization, it will be deserialized as a Map. Actually you might want to have separate getter/setter if so; getter would return String for serialization (and needs @JsonRawValue); and setter would take either Map or Object. You could re-encode it to a String if that makes sense.",java.lang.object,java.util.map,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"But I think a work-around for your specific case would be to specify type as 'java.lang.Object', since this should work ok: for serialization, String will be output as is, and for deserialization, it will be deserialized as a Map. Actually you might want to have separate getter/setter if so; getter would return String for serialization (and needs @JsonRawValue); and setter would take either Map or Object. You could re-encode it to a String if that makes sense.",java.lang.object,com.fasterxml.jackson.annotation.jsonrawvalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"But I think a work-around for your specific case would be to specify type as 'java.lang.Object', since this should work ok: for serialization, String will be output as is, and for deserialization, it will be deserialized as a Map. Actually you might want to have separate getter/setter if so; getter would return String for serialization (and needs @JsonRawValue); and setter would take either Map or Object. You could re-encode it to a String if that makes sense.",java.lang.string,java.util.map,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"But I think a work-around for your specific case would be to specify type as 'java.lang.Object', since this should work ok: for serialization, String will be output as is, and for deserialization, it will be deserialized as a Map. Actually you might want to have separate getter/setter if so; getter would return String for serialization (and needs @JsonRawValue); and setter would take either Map or Object. You could re-encode it to a String if that makes sense.",java.lang.string,com.fasterxml.jackson.annotation.jsonrawvalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"But I think a work-around for your specific case would be to specify type as 'java.lang.Object', since this should work ok: for serialization, String will be output as is, and for deserialization, it will be deserialized as a Map. Actually you might want to have separate getter/setter if so; getter would return String for serialization (and needs @JsonRawValue); and setter would take either Map or Object. You could re-encode it to a String if that makes sense.",java.util.map,com.fasterxml.jackson.annotation.jsonrawvalue,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"EDITED: If you're inside a Servlet object, then call getServletContext(). If you're in JSP, use the predefined variable application.",javax.servlet.servlet.getservletcontext,javax.servlet.servletcontext.application,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Combining two filter instances creates more objects and hence more delegating code but this can change if you use method references rather than lambda expressions, e.g. replace filter(x -&gt; x.isCool()) by filter(ItemType::isCool). That way you have eliminated the synthetic delegating method created for your lambda expression. So combining two filters using two method references might create the same or lesser delegation code than a single filter invocation using a lambda expression with &amp;&amp;.",java.util.stream.stream.filter,itemtype.iscool,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"You should also note that you might be better off using the click() method of the WebElement interface, but disabling native events before instantiating your driver. This would accomplish the same goal (with the same potential limitations), but not force you to write and maintain your own JavaScript.",org.openqa.selenium.webelement.click,org.openqa.selenium.webelement,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"You should also note that you might be better off using the click() method of the WebElement interface, but disabling native events before instantiating your driver. This would accomplish the same goal (with the same potential limitations), but not force you to write and maintain your own JavaScript.",org.openqa.selenium.webelement.click,java.awt.robot.setautowaitforidle,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"You should also note that you might be better off using the click() method of the WebElement interface, but disabling native events before instantiating your driver. This would accomplish the same goal (with the same potential limitations), but not force you to write and maintain your own JavaScript.",org.openqa.selenium.webelement,java.awt.robot.setautowaitforidle,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"First, it is only string literals (see notes) that get automatically interned / added to the string pool.  String objects that are created by an application at runtime are not interned ... unless your application explicitly calls String.intern().",java.lang.string,java.lang.string.intern,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
EDIT: with cancel(true); you have to (always) cautgh an exception java.util.concurrent.CancellationException,java.util.concurrent.future.cancel,java.util.concurrent.cancellationexception,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"There is no need for LinkedList.Entry to be  top-level class as it is only used by LinkedList (there are some other interfaces that also have static nested classes named Entry, such as Map.Entry - same concept). And since it does not need access to LinkedList's members, it makes sense for it to be static - it's a much cleaner approach.",java.util.linkedlist.entry,java.util.map.entry,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"By calling Thread.currentThread().interrupt(), you set the interrupt flag of the thread, so higher-level interrupt handlers will notice it and can handle it appropriately.",java.lang.thread.currentthread.interrupt,java.lang.thread,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"By calling Thread.currentThread().interrupt(), you set the interrupt flag of the thread, so higher-level interrupt handlers will notice it and can handle it appropriately.",java.lang.thread.currentthread.interrupt,java.lang.thread.interrupt,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"By calling Thread.currentThread().interrupt(), you set the interrupt flag of the thread, so higher-level interrupt handlers will notice it and can handle it appropriately.",java.lang.thread,java.lang.thread.interrupt,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The exact behavior of System.identityHashCode(Object) depends on the JVM implementation.  (The actual implementation on recent Hotspot JVMs is rather clever, but I digress.)",java.lang.system.identityhashcode,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
For a Collection (or Map):  use .size().,java.util.collection,java.util.map,"[('yes', 'no', 'yes', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
For a Collection (or Map):  use .size().,java.util.collection,java.util.collection.size,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
For a Collection (or Map):  use .size().,java.util.collection,java.util.map.size,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
For a Collection (or Map):  use .size().,java.util.map,java.util.collection.size,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
For a Collection (or Map):  use .size().,java.util.map,java.util.map.size,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
For a Collection (or Map):  use .size().,java.util.collection.size,java.util.map.size,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Also, getScaledInstance() is generally a bad idea. This explains why and gives better options for resizing the image. If you're using the image elsewhere, then it's worth reading up on that article and scaling it using a better technique (such as graphics.drawImage()). But if you're just using it in the menu, then resizing the source image is probably the best thing to do.",java.awt.image.getscaledinstance,java.awt.graphics.drawimage,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Avoid the Date object creation w/ System.currentTimeMillis().  A divide by 1000 gets you to Unix epoch.,java.util.date,java.lang.system.currenttimemillis,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The problem is related (I believe) on how the localhost name resolution works and how the java.net.InetAddr class is retrieving the addresses. I verified with few colleagues and apparently it doesn't happen to everyone who upgraded to Sierra, but I'm still investigating the roots of this change.",java.net.inetaddress.localhost,java.net.inetaddr,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"There are many, many other reasons to use Joda Time or java.time instead of the built-in java.util types - they're generally far better APIs. You can always convert to/from a java.util.Date at the boundaries of your own code if you need to, e.g. for database interaction.",java.time,java.util,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"There are many, many other reasons to use Joda Time or java.time instead of the built-in java.util types - they're generally far better APIs. You can always convert to/from a java.util.Date at the boundaries of your own code if you need to, e.g. for database interaction.",java.util,org.joda.time.datetime,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"There are many, many other reasons to use Joda Time or java.time instead of the built-in java.util types - they're generally far better APIs. You can always convert to/from a java.util.Date at the boundaries of your own code if you need to, e.g. for database interaction.",java.util,java.time.localdatetime,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"There are many, many other reasons to use Joda Time or java.time instead of the built-in java.util types - they're generally far better APIs. You can always convert to/from a java.util.Date at the boundaries of your own code if you need to, e.g. for database interaction.",org.joda.time.datetime,java.time.localdatetime,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"There are many, many other reasons to use Joda Time or java.time instead of the built-in java.util types - they're generally far better APIs. You can always convert to/from a java.util.Date at the boundaries of your own code if you need to, e.g. for database interaction.",java.time.localdatetime,java.util.date,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
The first solution (with the MockitoAnnotations.initMocks) could be used when you have already configured a specific runner (SpringJUnit4ClassRunner for example) on your test case.,org.mockito.mockitoannotations.initmocks,org.springframework.test.context.junit4.springjunit4classrunner,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"You haven't provided Spring Boot with enough information to auto-configure a DataSource. To do so, you'll need to add some properties to application.properties with the spring.datasource prefix. Take a look at DataSourceProperties to see all of the properties that you can set. ",javax.sql.datasource,org.springframework.boot.autoconfigure.jdbc.datasourceproperties,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"You haven't provided Spring Boot with enough information to auto-configure a DataSource. To do so, you'll need to add some properties to application.properties with the spring.datasource prefix. Take a look at DataSourceProperties to see all of the properties that you can set. ",javax.sql.datasource,spring.datasource,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"You haven't provided Spring Boot with enough information to auto-configure a DataSource. To do so, you'll need to add some properties to application.properties with the spring.datasource prefix. Take a look at DataSourceProperties to see all of the properties that you can set. ",org.springframework.boot.autoconfigure.jdbc.datasourceproperties,spring.datasource,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Sometimes there will be situations where you don't want to force every method to declare your exception implementation in its throws clause.  In this case you can create an unchecked exception.  An unchecked exception is any exception that extends java.lang.RuntimeException (which itself is a subclass of java.lang.Exception):,java.lang.runtimeexception,java.lang.exception,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager,java.sql.drivermanager.getconnection,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager,java.sql.drivermanager.getdrivers,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager,java.sql.driver,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager,my.sql.driver,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager.getconnection,java.sql.drivermanager.getdrivers,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager.getconnection,java.sql.driver,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager.getconnection,my.sql.driver,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager.getdrivers,java.sql.driver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.drivermanager.getdrivers,my.sql.driver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:",java.sql.driver,my.sql.driver,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
System.setOut(PrintStream ps),java.lang.system.setout,java.io.printstream,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Note: Some flavors of regex support the nesting operator R (Java doesn't, PCRE engines like PHP and Perl do), which allows you to nest arbitrary number of levels. With them, you could do: \(([^()]|(?R))*\).",java.util.regex.pattern,java.util.regex.pattern.r,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Note: Some flavors of regex support the nesting operator R (Java doesn't, PCRE engines like PHP and Perl do), which allows you to nest arbitrary number of levels. With them, you could do: \(([^()]|(?R))*\).",java.util.regex.pattern,java.util.regex.pattern.compile,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Note: Some flavors of regex support the nesting operator R (Java doesn't, PCRE engines like PHP and Perl do), which allows you to nest arbitrary number of levels. With them, you could do: \(([^()]|(?R))*\).",java.util.regex.pattern,java.util.regex.pattern.compile,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
You need to override the method paintComponent(Graphics g) of JPanel and use drawImage() on the Graphics object g as in this example.,javax.swing.jpanel.paintcomponent,java.awt.graphics,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You need to override the method paintComponent(Graphics g) of JPanel and use drawImage() on the Graphics object g as in this example.,javax.swing.jpanel.paintcomponent,java.awt.graphics.drawimage,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
You need to override the method paintComponent(Graphics g) of JPanel and use drawImage() on the Graphics object g as in this example.,java.awt.graphics,java.awt.graphics.drawimage,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"This uses a java.util.Scanner, telling it to delimit the input with \Z, which is the end of the string anchor. This ultimately makes the input have one actual token, which is the entire file, so it can be read with one call to next().",java.util.scanner,java.util.scanner.next,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
java.util.UUID.randomUUID();,java.util.uuid.randomuuid,java.util.uuid,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"If you need to do anything more complicated than this, I would recommend looking at the Pattern and Matcher classes and learning how to do some regular expressions. Once you understand those, you can use those classes or the String.matches() helper method.",java.util.regex.pattern,java.lang.string.matches,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"If you need to do anything more complicated than this, I would recommend looking at the Pattern and Matcher classes and learning how to do some regular expressions. Once you understand those, you can use those classes or the String.matches() helper method.",java.util.regex.matcher,java.lang.string.matches,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
Casting of an object does NOT change anything; it is just the way the compiler treats it.instanceof or Class.isInstance().,java.lang.object.instanceof,java.lang.class.isinstance,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no')]"
"As for the problem with failed tests, you can  set maven.test.error.ignore so that the build continues on failed tests.  This is not recommended as a continuing practice, but it should get you functioning until all of your tests pass. For more detail, see the maven surefire documentation.",org.apache.maven.surefire.testset.maventestset.maven.test.error.ignore,org.apache.maven,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"As for the problem with failed tests, you can  set maven.test.error.ignore so that the build continues on failed tests.  This is not recommended as a continuing practice, but it should get you functioning until all of your tests pass. For more detail, see the maven surefire documentation.",org.apache.maven.surefire.testset.maventestset.maven.test.error.ignore,org.apache.maven.surefire,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"As for the problem with failed tests, you can  set maven.test.error.ignore so that the build continues on failed tests.  This is not recommended as a continuing practice, but it should get you functioning until all of your tests pass. For more detail, see the maven surefire documentation.",org.apache.maven,org.apache.maven.surefire,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Consider StringimplementsCharSequence as an example. You should not just blindly use CharSequence in preferrence to String for all cases, because that would deny you simple operations like trim(), toUpperCase(), etc.",java.lang.string,java.lang.string.trim,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"Consider StringimplementsCharSequence as an example. You should not just blindly use CharSequence in preferrence to String for all cases, because that would deny you simple operations like trim(), toUpperCase(), etc.",java.lang.string,java.lang.string.touppercase,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"Consider StringimplementsCharSequence as an example. You should not just blindly use CharSequence in preferrence to String for all cases, because that would deny you simple operations like trim(), toUpperCase(), etc.",java.lang.charsequence,java.lang.string.trim,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"Consider StringimplementsCharSequence as an example. You should not just blindly use CharSequence in preferrence to String for all cases, because that would deny you simple operations like trim(), toUpperCase(), etc.",java.lang.charsequence,java.lang.string.touppercase,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"Consider StringimplementsCharSequence as an example. You should not just blindly use CharSequence in preferrence to String for all cases, because that would deny you simple operations like trim(), toUpperCase(), etc.",java.lang.string.trim,java.lang.string.touppercase,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
You can use Class#getDeclaredFields() to get all declared fields of the class. You can use Field#get() to get the value.,java.lang.class.getdeclaredfields,java.lang.reflect.field.get,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"Map this filter on an url-pattern for which you'd like to log responses for. Keep in mind that binary/static content like images, CSS, JS files and so on won't be logged this way. You'd like to exclude them by using a specific enough url-pattern, e.g. *.jsp or just on the servlet-name of the servlet in question. If you want to log binary/static content anyway (for which I don't see any benefit), then you need to replace the HttpServletResponse#getOutputStream() the same way as well.",java.util.map,java.util.filter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Map this filter on an url-pattern for which you'd like to log responses for. Keep in mind that binary/static content like images, CSS, JS files and so on won't be logged this way. You'd like to exclude them by using a specific enough url-pattern, e.g. *.jsp or just on the servlet-name of the servlet in question. If you want to log binary/static content anyway (for which I don't see any benefit), then you need to replace the HttpServletResponse#getOutputStream() the same way as well.",java.util.map,java.net.urlpattern,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Map this filter on an url-pattern for which you'd like to log responses for. Keep in mind that binary/static content like images, CSS, JS files and so on won't be logged this way. You'd like to exclude them by using a specific enough url-pattern, e.g. *.jsp or just on the servlet-name of the servlet in question. If you want to log binary/static content anyway (for which I don't see any benefit), then you need to replace the HttpServletResponse#getOutputStream() the same way as well.",java.util.map,javax.servlet.http.httpservletresponse.getoutputstream,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Map this filter on an url-pattern for which you'd like to log responses for. Keep in mind that binary/static content like images, CSS, JS files and so on won't be logged this way. You'd like to exclude them by using a specific enough url-pattern, e.g. *.jsp or just on the servlet-name of the servlet in question. If you want to log binary/static content anyway (for which I don't see any benefit), then you need to replace the HttpServletResponse#getOutputStream() the same way as well.",java.util.filter,java.net.urlpattern,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Map this filter on an url-pattern for which you'd like to log responses for. Keep in mind that binary/static content like images, CSS, JS files and so on won't be logged this way. You'd like to exclude them by using a specific enough url-pattern, e.g. *.jsp or just on the servlet-name of the servlet in question. If you want to log binary/static content anyway (for which I don't see any benefit), then you need to replace the HttpServletResponse#getOutputStream() the same way as well.",java.util.filter,javax.servlet.http.httpservletresponse.getoutputstream,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Map this filter on an url-pattern for which you'd like to log responses for. Keep in mind that binary/static content like images, CSS, JS files and so on won't be logged this way. You'd like to exclude them by using a specific enough url-pattern, e.g. *.jsp or just on the servlet-name of the servlet in question. If you want to log binary/static content anyway (for which I don't see any benefit), then you need to replace the HttpServletResponse#getOutputStream() the same way as well.",java.net.urlpattern,javax.servlet.http.httpservletresponse.getoutputstream,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Don't override paint components, use paintComponent and don't forget to call super.paintComponent",javax.swing.jcomponent.paintcomponent,java.awt.component.paintcomponent,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
Would you even want to override [Activity|ViewGroup|View].dispatchTouchEvent? Unless you are doing some custom routing you probably should not.,android.app.activity.dispatchtouchevent,android.view.viewgroup.dispatchtouchevent,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'yes', 'yes')]"
Would you even want to override [Activity|ViewGroup|View].dispatchTouchEvent? Unless you are doing some custom routing you probably should not.,android.app.activity.dispatchtouchevent,android.view.view.dispatchtouchevent,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger,com.fizz,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger,java.util.logging.logger.alle,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger,java.util.logging.logger.root logger,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger,java.util.logging.logger.newappender.,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",com.fizz,java.util.logging.logger.alle,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",com.fizz,java.util.logging.logger.root logger,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",com.fizz,java.util.logging.logger.newappender.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger.alle,java.util.logging.logger.root logger,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger.alle,java.util.logging.logger.newappender.,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"will give you a logger for the category ""com.fizz"".fizz will be handled by alle the appenders from the root logger and the newAppender.",java.util.logging.logger.root logger,java.util.logging.logger.newappender.,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Throwable.printStackTrace() writes the stack trace to System.err PrintStream. The System.err stream and the underlying standard ""error"" output stream of the JVM process can be redirected by",java.lang.throwable.printstacktrace,java.lang.system.err,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Throwable.printStackTrace() writes the stack trace to System.err PrintStream. The System.err stream and the underlying standard ""error"" output stream of the JVM process can be redirected by",java.lang.throwable.printstacktrace,java.io.printstream,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Throwable.printStackTrace() writes the stack trace to System.err PrintStream. The System.err stream and the underlying standard ""error"" output stream of the JVM process can be redirected by",java.lang.system.err,java.io.printstream,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"EDIT: Now that Java 8 has been released, if you can use that, do so! java.time is even cleaner than Joda Time, in my view. However, if you're stuck pre-Java-8, read on...",java.time,org.joda.time.,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"The Java String class provides the .compareTo () method in order to lexicographically compare Strings. It is used like this ""apple"".compareTo (""banana"").",java.lang.string.compareto,java.lang.string,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"Use the Socket() constructor, and connect(SocketAddress endpoint, int timeout) method instead.",java.net.socket,java.net.socketaddress,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Use the Socket() constructor, and connect(SocketAddress endpoint, int timeout) method instead.",java.net.socket,java.net.socket.connect,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"Use the Socket() constructor, and connect(SocketAddress endpoint, int timeout) method instead.",java.net.socket,java.net.socket.timeout,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Use the Socket() constructor, and connect(SocketAddress endpoint, int timeout) method instead.",java.net.socketaddress,java.net.socket.connect,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Use the Socket() constructor, and connect(SocketAddress endpoint, int timeout) method instead.",java.net.socketaddress,java.net.socket.timeout,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Use the Socket() constructor, and connect(SocketAddress endpoint, int timeout) method instead.",java.net.socket.connect,java.net.socket.timeout,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
Stream.of(T...).filter(Objects::nonNull).findFirst().orElse(null),java.util.stream.stream.of,java.util.objects.nonnull,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Stream.of(T...).filter(Objects::nonNull).findFirst().orElse(null),java.util.stream.stream.of,java.util.stream.stream.findfirst,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
Stream.of(T...).filter(Objects::nonNull).findFirst().orElse(null),java.util.stream.stream.of,java.util.optional.orelse,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Stream.of(T...).filter(Objects::nonNull).findFirst().orElse(null),java.util.objects.nonnull,java.util.stream.stream.findfirst,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Stream.of(T...).filter(Objects::nonNull).findFirst().orElse(null),java.util.objects.nonnull,java.util.optional.orelse,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
Stream.of(T...).filter(Objects::nonNull).findFirst().orElse(null),java.util.stream.stream.findfirst,java.util.optional.orelse,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"Note that parse() will never return null, so this cannot cause a NullPointerException. Instead, parse throws a checked ParseException if it fails.",java.text.dateformat.parse,java.text.parseexception,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
A ScatterRenderer inherits getItemShape() from AbstractRenderer. You can override getItemShape() to supply your own shapes.,org.jfree.chart.renderer.abstractrenderer.getitemshape,org.jfree.chart.renderer.abstractrenderer,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
A ScatterRenderer inherits getItemShape() from AbstractRenderer. You can override getItemShape() to supply your own shapes.,org.jfree.chart.renderer.abstractrenderer.getitemshape,org.jfree.chart.renderer.scatterrenderer,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
A ScatterRenderer inherits getItemShape() from AbstractRenderer. You can override getItemShape() to supply your own shapes.,org.jfree.chart.renderer.abstractrenderer,org.jfree.chart.renderer.scatterrenderer,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Alternatively, you could accept a String and return a String. Just construct the JSONObject with the string parameter, and call JSONObject.toString() when returning.",java.lang.string,org.json.jsonobject.tostring,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Addendum: Alternatively, you can scale the image first (using either approach above) and then use your RescaleOp in drawImage().",java.awt.image.rescaleop,java.awt.graphics.drawimage,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"As I mentioned above, we had been talking to the Guava developers. One of the cool things they have is an Idea Graveyard where they describe features that they decided not to implement along with the reasons. The idea of lazy collections sounds pretty cool, but here's what they have to say about it. Consider a List.filter() operation that returns a List:",java.util.list.filter,java.util.list,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Now to the implied question ""how do you get the element then"": I think the best solution is to use a Map&lt;E,E&gt; instead of a Set&lt;E&gt;, to map the elements to themselves. In that way, you can efficiently retrieve an element from the ""set"", because the get() method of the Map will find the element using an efficient hash table or tree algorithm. If you wanted, you could write your own implementation of Set that offers the additional get() method, encapsulating the Map.",java.lang.object,java.util.set,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Now to the implied question ""how do you get the element then"": I think the best solution is to use a Map&lt;E,E&gt; instead of a Set&lt;E&gt;, to map the elements to themselves. In that way, you can efficiently retrieve an element from the ""set"", because the get() method of the Map will find the element using an efficient hash table or tree algorithm. If you wanted, you could write your own implementation of Set that offers the additional get() method, encapsulating the Map.",java.util.set,java.util.map.get,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Now to the implied question ""how do you get the element then"": I think the best solution is to use a Map&lt;E,E&gt; instead of a Set&lt;E&gt;, to map the elements to themselves. In that way, you can efficiently retrieve an element from the ""set"", because the get() method of the Map will find the element using an efficient hash table or tree algorithm. If you wanted, you could write your own implementation of Set that offers the additional get() method, encapsulating the Map.",java.util.map.get,java.util.set,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"@see JavaDoc: ReflectionTestUtils.setField(java.lang.Object, java.lang.String, java.lang.Object)",org.springframework.test.util.reflectiontestutils.setfield,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"@see JavaDoc: ReflectionTestUtils.setField(java.lang.Object, java.lang.String, java.lang.Object)",org.springframework.test.util.reflectiontestutils.setfield,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"size() --  Collection Object (ArrayList, Set, etc) -- to know the size of the Collection ",java.util.collection.size,java.util.collection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"size() --  Collection Object (ArrayList, Set, etc) -- to know the size of the Collection ",java.util.collection.size,java.util.arraylist,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"size() --  Collection Object (ArrayList, Set, etc) -- to know the size of the Collection ",java.util.collection.size,java.util.set,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"size() --  Collection Object (ArrayList, Set, etc) -- to know the size of the Collection ",java.util.collection,java.util.set,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"size() --  Collection Object (ArrayList, Set, etc) -- to know the size of the Collection ",java.util.arraylist,java.util.set,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
Now forget about length() consider just length and size().,java.lang.string.length,java.util.collection.size,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
classDirectories = files(classDirectories.files.collect { instead of classDirectories.setFrom,java.nio.file.files.files,java.util.stream.stream.collect,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
classDirectories = files(classDirectories.files.collect { instead of classDirectories.setFrom,java.nio.file.files.files,java.nio.file.path.setfrom,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
classDirectories = files(classDirectories.files.collect { instead of classDirectories.setFrom,java.util.stream.stream.collect,java.nio.file.path.setfrom,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The javaws command launches Java Web Start, which is the reference implementation of the Java Network Launching Protocol (JNLP). Java Web Start launches Java applications/applets hosted on a network.  javaws will launch the Java application/applet specified in the JNLP file.javaws launcher has a set of options that are supported in the current release. However, the options may be removed in a future release.",java.net.javaws.javawebstart,java.net.jnlp,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The javaws command launches Java Web Start, which is the reference implementation of the Java Network Launching Protocol (JNLP). Java Web Start launches Java applications/applets hosted on a network.  javaws will launch the Java application/applet specified in the JNLP file.javaws launcher has a set of options that are supported in the current release. However, the options may be removed in a future release.",java.net.javaws.javawebstart,java.lang,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The javaws command launches Java Web Start, which is the reference implementation of the Java Network Launching Protocol (JNLP). Java Web Start launches Java applications/applets hosted on a network.  javaws will launch the Java application/applet specified in the JNLP file.javaws launcher has a set of options that are supported in the current release. However, the options may be removed in a future release.",java.net.jnlp,java.lang,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.localfilesystem,org.apache.hadoop.fs.distributedfilesystem,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.localfilesystem,org.apache.hadoop.fs.filesystem,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.localfilesystem,java.util.serviceloader,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.localfilesystem,org.apache.hadoop.filesystem,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.localfilesystem,org.apache.hadoop.filesystem#loadfilesystems,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.distributedfilesystem,org.apache.hadoop.fs.filesystem,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.distributedfilesystem,java.util.serviceloader,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.distributedfilesystem,org.apache.hadoop.filesystem,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.distributedfilesystem,org.apache.hadoop.filesystem#loadfilesystems,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.filesystem,java.util.serviceloader,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.filesystem,org.apache.hadoop.filesystem,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.fs.filesystem,org.apache.hadoop.filesystem#loadfilesystems,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",java.util.serviceloader,org.apache.hadoop.filesystem,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",java.util.serviceloader,org.apache.hadoop.filesystem#loadfilesystems,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Different JARs (hadoop-commons for LocalFileSystem, hadoop-hdfs for DistributedFileSystem) each contain a different file called org.apache.hadoop.fs.FileSystem in their META-INFO/services directory. This file lists the canonical classnames of the filesystem implementations they want to declare (This is called a Service Provider Interface implemented via java.util.ServiceLoader, see org.apache.hadoop.FileSystem#loadFileSystems).",org.apache.hadoop.filesystem,org.apache.hadoop.filesystem#loadfilesystems,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"When we use maven-assembly-plugin, it merges all our JARs into one, and all META-INFO/services/org.apache.hadoop.fs.FileSystem overwrite each-other. Only one of these files remains (the last one that was added). In this case, the FileSystem list from hadoop-commons overwrites the list from hadoop-hdfs, so DistributedFileSystem was no longer declared.",org.apache.maven.plugins.assembly.plugin.assemblyplugin,org.apache.hadoop.fs.filesystem,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"When we use maven-assembly-plugin, it merges all our JARs into one, and all META-INFO/services/org.apache.hadoop.fs.FileSystem overwrite each-other. Only one of these files remains (the last one that was added). In this case, the FileSystem list from hadoop-commons overwrites the list from hadoop-hdfs, so DistributedFileSystem was no longer declared.",org.apache.maven.plugins.assembly.plugin.assemblyplugin,org.apache.hadoop.fs.distributedfilesystem,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"When we use maven-assembly-plugin, it merges all our JARs into one, and all META-INFO/services/org.apache.hadoop.fs.FileSystem overwrite each-other. Only one of these files remains (the last one that was added). In this case, the FileSystem list from hadoop-commons overwrites the list from hadoop-hdfs, so DistributedFileSystem was no longer declared.",org.apache.hadoop.fs.filesystem,org.apache.hadoop.fs.distributedfilesystem,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_coarse_location,android.manifest.permission.access_fine_location,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_coarse_location,android.manifest.permission.write_external_storage,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_coarse_location,android.app.activity.requestpermissions,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_coarse_location,android.app.activity.checkselfpermission,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_fine_location,android.manifest.permission.write_external_storage,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_fine_location,android.app.activity.requestpermissions,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.access_fine_location,android.app.activity.checkselfpermission,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.write_external_storage,android.app.activity.requestpermissions,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.manifest.permission.write_external_storage,android.app.activity.checkselfpermission,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION, and WRITE_EXTERNAL_STORAGE are all part of the Android 6.0 runtime permission system. In addition to having them in the manifest as you do, you also have to request them from the user at runtime (using requestPermissions()) and see if you have them (using checkSelfPermission()).",android.app.activity.requestpermissions,android.app.activity.checkselfpermission,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Java 8 has Math.multiplyExact, Math.addExact etc. for ints and long. These throw an unchecked ArithmeticException on overflow.",java.lang.math.multiplyexact,java.lang.math.addexact,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Java 8 has Math.multiplyExact, Math.addExact etc. for ints and long. These throw an unchecked ArithmeticException on overflow.",java.lang.math.multiplyexact,java.lang.arithmeticexception,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Java 8 has Math.multiplyExact, Math.addExact etc. for ints and long. These throw an unchecked ArithmeticException on overflow.",java.lang.math.addexact,java.lang.arithmeticexception,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
mLeft (protected variable in View class) ==&gt; getLeft() (public accessor method),android.view.view.mleft,android.view.view.getleft,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"You need to make the same change to use &lt; newGuess.length() when printing out the content too - otherwise for an array of length 4 (which has valid indexes 0, 1, 2, 3) you'll try to use newGuess[4]. The vast majority of for loops I write use &lt; in the condition, rather than &lt;=.",java.lang.string.length,java.lang.string[] newguess,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Implementation note: BigInteger constructors and operations throw ArithmeticException when the result is out of the supported range of -2Integer.MAX_VALUE (exclusive) to +2Integer.MAX_VALUE (exclusive).,java.math.biginteger,java.lang.arithmeticexception,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
Implementation note: BigInteger constructors and operations throw ArithmeticException when the result is out of the supported range of -2Integer.MAX_VALUE (exclusive) to +2Integer.MAX_VALUE (exclusive).,java.lang.arithmeticexception,java.lang.integer.max_value,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"The problem with Linked Resources is they are local to the workspace, in the preferences.export the preferences in a [myPrefs.epf] file, and then trim the exported file in order to leave only the lines containing pathvariable:",org.eclipse.core.resources.linkedresources,org.eclipse.core.runtime.preferences.preferences,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The problem with Linked Resources is they are local to the workspace, in the preferences.export the preferences in a [myPrefs.epf] file, and then trim the exported file in order to leave only the lines containing pathvariable:",org.eclipse.core.resources.linkedresources,org.eclipse.core.runtime.pathvariable,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The problem with Linked Resources is they are local to the workspace, in the preferences.export the preferences in a [myPrefs.epf] file, and then trim the exported file in order to leave only the lines containing pathvariable:",org.eclipse.core.runtime.preferences.preferences,org.eclipse.core.runtime.pathvariable,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane. Note that Canvas returns false from isResizable(), so ""the parent cannot resize it during layout,"" and Pane ""does not perform layout beyond resizing resizable children to their preferred sizes."" The width and height used to construct the canvas become its initial size. A similar approach is used in the Ensemble particle simulation, Fireworks.java, to scale a background image while retaining its aspect ratio.",java.awt.canvas,java.awt.component.isresizable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane. Note that Canvas returns false from isResizable(), so ""the parent cannot resize it during layout,"" and Pane ""does not perform layout beyond resizing resizable children to their preferred sizes."" The width and height used to construct the canvas become its initial size. A similar approach is used in the Ensemble particle simulation, Fireworks.java, to scale a background image while retaining its aspect ratio.",java.awt.canvas,javafx.scene.layout.pane,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane. Note that Canvas returns false from isResizable(), so ""the parent cannot resize it during layout,"" and Pane ""does not perform layout beyond resizing resizable children to their preferred sizes."" The width and height used to construct the canvas become its initial size. A similar approach is used in the Ensemble particle simulation, Fireworks.java, to scale a background image while retaining its aspect ratio.",java.awt.canvas,javafx.scene.layout.pane.layoutchildren,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane. Note that Canvas returns false from isResizable(), so ""the parent cannot resize it during layout,"" and Pane ""does not perform layout beyond resizing resizable children to their preferred sizes."" The width and height used to construct the canvas become its initial size. A similar approach is used in the Ensemble particle simulation, Fireworks.java, to scale a background image while retaining its aspect ratio.",java.awt.component.isresizable,javafx.scene.layout.pane,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane. Note that Canvas returns false from isResizable(), so ""the parent cannot resize it during layout,"" and Pane ""does not perform layout beyond resizing resizable children to their preferred sizes."" The width and height used to construct the canvas become its initial size. A similar approach is used in the Ensemble particle simulation, Fireworks.java, to scale a background image while retaining its aspect ratio.",java.awt.component.isresizable,javafx.scene.layout.pane.layoutchildren,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"In the example below, the static nested class CanvasPane wraps an instance of Canvas in a Pane and overrides layoutChildren() to make the canvas dimensions match the enclosing Pane. Note that Canvas returns false from isResizable(), so ""the parent cannot resize it during layout,"" and Pane ""does not perform layout beyond resizing resizable children to their preferred sizes."" The width and height used to construct the canvas become its initial size. A similar approach is used in the Ensemble particle simulation, Fireworks.java, to scale a background image while retaining its aspect ratio.",javafx.scene.layout.pane,javafx.scene.layout.pane.layoutchildren,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Guided by ChartFactory.createXYLineChart(), simply specify a XYToolTipGenerator to the renderer. The default format, seen here, is Series: (x, y).",org.jfree.chart.chartfactory.createxylinechart,org.jfree.chart.labels.xytooltipgenerator,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Guided by ChartFactory.createXYLineChart(), simply specify a XYToolTipGenerator to the renderer. The default format, seen here, is Series: (x, y).",org.jfree.chart.chartfactory.createxylinechart,org.jfree.data.xy.xyseries,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"Guided by ChartFactory.createXYLineChart(), simply specify a XYToolTipGenerator to the renderer. The default format, seen here, is Series: (x, y).",org.jfree.chart.labels.xytooltipgenerator,org.jfree.data.xy.xyseries,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"I know its ugly but it does not use any funny stuff just legacy OpenGL and Math.h (cos(),sin(),M_PI) and VCL for bitmap loading. So rewrite to your environment and you will be fine. Do not forget that each planet has its own texture so you need to have one txrid per planet so either have each planet as separate planet variable or rewrite ...",java.lang.math.cos,java.lang.math.sin,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"I know its ugly but it does not use any funny stuff just legacy OpenGL and Math.h (cos(),sin(),M_PI) and VCL for bitmap loading. So rewrite to your environment and you will be fine. Do not forget that each planet has its own texture so you need to have one txrid per planet so either have each planet as separate planet variable or rewrite ...",java.lang.math.cos,java.lang.math.pi,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"I know its ugly but it does not use any funny stuff just legacy OpenGL and Math.h (cos(),sin(),M_PI) and VCL for bitmap loading. So rewrite to your environment and you will be fine. Do not forget that each planet has its own texture so you need to have one txrid per planet so either have each planet as separate planet variable or rewrite ...",java.lang.math.sin,java.lang.math.pi,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
Collections.synchronizedList is normally used at the time of creation of the list to avoid any accidental unsynchronized access to the list.,java.util.collections.synchronizedlist,java.util.list,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"Prior to Java 8, you produce a concurrent hash set backed by a concurrent hash map, by using Collections.newSetFromMap(map)",java.util.collections.newsetfrommap,java.util.map,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"In Java 8 (pointed out by @Matt), you can get a concurrent hash set view via ConcurrentHashMap.newKeySet(). This is a bit simpler than the old newSetFromMap which required you to pass in an empty map object. But it is specific to ConcurrentHashMap.",java.util.concurrent.concurrenthashmap.newkeyset,java.util.collections.newsetfrommap,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"I will show you few examples, together with hashCode() of each String and hashCode() of internal char[] value field (I will call it text to distinguish it from string). Finally I'll show javap -c -verbose output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also Understanding javap's output for the Constant Pool.",java.lang.object.hashcode,java.lang.string.text,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"I will show you few examples, together with hashCode() of each String and hashCode() of internal char[] value field (I will call it text to distinguish it from string). Finally I'll show javap -c -verbose output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also Understanding javap's output for the Constant Pool.",java.lang.object.hashcode,java.lang.processbuilder.javap,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"I will show you few examples, together with hashCode() of each String and hashCode() of internal char[] value field (I will call it text to distinguish it from string). Finally I'll show javap -c -verbose output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also Understanding javap's output for the Constant Pool.",java.lang.object.hashcode,java.lang.class.constant pool,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"I will show you few examples, together with hashCode() of each String and hashCode() of internal char[] value field (I will call it text to distinguish it from string). Finally I'll show javap -c -verbose output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also Understanding javap's output for the Constant Pool.",java.lang.string.text,java.lang.processbuilder.javap,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"I will show you few examples, together with hashCode() of each String and hashCode() of internal char[] value field (I will call it text to distinguish it from string). Finally I'll show javap -c -verbose output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also Understanding javap's output for the Constant Pool.",java.lang.string.text,java.lang.class.constant pool,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"I will show you few examples, together with hashCode() of each String and hashCode() of internal char[] value field (I will call it text to distinguish it from string). Finally I'll show javap -c -verbose output, together with constant pool for my test class. Please do not confuse class constant pool with string literal pool. They are not quite the same. See also Understanding javap's output for the Constant Pool.",java.lang.processbuilder.javap,java.lang.class.constant pool,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
synchronized(X.class) is used to make sure that there is exactly one Thread in the block. synchronized(this) ensures that there is exactly one thread per instance. If this makes the actual code in the block thread-safe depends on the implementation. If mutate only state of the instance synchronized(this) is enough.,java.lang.object.synchronized,java.lang.object.this,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Per Byron's answer, you can't set networkaddress.cache.ttl or networkaddress.cache.negative.ttl as System Properties by using the -D flag or calling System.setProperty because these are not System properties - they are Security properties.",java.net.networkaddresscache.ttl,java.net.networkaddresscache.negative.ttl,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Per Byron's answer, you can't set networkaddress.cache.ttl or networkaddress.cache.negative.ttl as System Properties by using the -D flag or calling System.setProperty because these are not System properties - they are Security properties.",java.net.networkaddresscache.ttl,java.lang.system.setproperty,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Per Byron's answer, you can't set networkaddress.cache.ttl or networkaddress.cache.negative.ttl as System Properties by using the -D flag or calling System.setProperty because these are not System properties - they are Security properties.",java.net.networkaddresscache.ttl,java.security.security.properties,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Per Byron's answer, you can't set networkaddress.cache.ttl or networkaddress.cache.negative.ttl as System Properties by using the -D flag or calling System.setProperty because these are not System properties - they are Security properties.",java.net.networkaddresscache.negative.ttl,java.lang.system.setproperty,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"Per Byron's answer, you can't set networkaddress.cache.ttl or networkaddress.cache.negative.ttl as System Properties by using the -D flag or calling System.setProperty because these are not System properties - they are Security properties.",java.net.networkaddresscache.negative.ttl,java.security.security.properties,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Per Byron's answer, you can't set networkaddress.cache.ttl or networkaddress.cache.negative.ttl as System Properties by using the -D flag or calling System.setProperty because these are not System properties - they are Security properties.",java.lang.system.setproperty,java.security.security.properties,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"This is important because, for example, if you called Security.setProperty in a .war file and deployed that .war to Tomcat, this wouldn't work: Tomcat uses the Java networking stack to initialize itself much earlier than your .war's code is executed.  Because of this 'race condition', it is usually more convenient to use the -D flag when starting the JVM process. ",java.security.security.setproperty,java.lang.java,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"This is important because, for example, if you called Security.setProperty in a .war file and deployed that .war to Tomcat, this wouldn't work: Tomcat uses the Java networking stack to initialize itself much earlier than your .war's code is executed.  Because of this 'race condition', it is usually more convenient to use the -D flag when starting the JVM process. ",java.security.security.setproperty,java.lang.system.getproperty,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"This is important because, for example, if you called Security.setProperty in a .war file and deployed that .war to Tomcat, this wouldn't work: Tomcat uses the Java networking stack to initialize itself much earlier than your .war's code is executed.  Because of this 'race condition', it is usually more convenient to use the -D flag when starting the JVM process. ",java.lang.java,java.lang.system.getproperty,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"If you don't use -Dsun.net.inetaddr.ttl=0 or call Security.setProperty, you will need to edit $JRE_HOME/lib/security/java.security and set those security properties in that file, e.g.",java.security.security.setproperty,java.security.java.security,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.nio.bytebuffer,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.io.dataoutputstream.read*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.io.dataoutputstream.write*,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.nio.bytebuffer.get*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.nio.bytebuffer.put*,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.io.serializable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer,java.io.dataoutputstream.read*,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer,java.io.dataoutputstream.write*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer,java.nio.bytebuffer.get*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer,java.nio.bytebuffer.put*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer,java.io.serializable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.read*,java.io.dataoutputstream.write*,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.read*,java.nio.bytebuffer.get*,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.read*,java.nio.bytebuffer.put*,"[('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.read*,java.io.serializable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.read*,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.write*,java.nio.bytebuffer.get*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.write*,java.nio.bytebuffer.put*,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.write*,java.io.serializable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.dataoutputstream.write*,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer.get*,java.nio.bytebuffer.put*,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer.get*,java.io.serializable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer.get*,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer.put*,java.io.serializable,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.nio.bytebuffer.put*,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For serialization of objects that do not implement the Serializable interface you either need to write your own serializer, for example using the read*/write* methods of java.io.DataOutputStream and the get*/put* methods of java.nio.ByteBuffer perhaps together with reflection, or pull in a third party dependency.",java.io.serializable,java.lang.reflect.reflection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"However, the usual answer in my experience is to have a static {} block at the end of all the static initializers, and do all static initialization there, using EnumSet.allOf  to get at all the values.",java.lang.object.static {},java.util.enumset.allof,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"However, if flush() throws a runtime exception for some reason, then out.close() will never be called.",java.io.outputstream.flush,java.io.outputstream.close,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"This will treat the pattern1 and pattern2 as literal text, and the text in between the patterns is captured in the first capturing group. You can remove Pattern.quote() if you want to use regex, but I don't guarantee anything if you do that.",java.util.regex.pattern.quote,java.util.regex.pattern,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"This will treat the pattern1 and pattern2 as literal text, and the text in between the patterns is captured in the first capturing group. You can remove Pattern.quote() if you want to use regex, but I don't guarantee anything if you do that.",java.util.regex.pattern.quote,java.util.regex.matcher.group,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"This will treat the pattern1 and pattern2 as literal text, and the text in between the patterns is captured in the first capturing group. You can remove Pattern.quote() if you want to use regex, but I don't guarantee anything if you do that.",java.util.regex.pattern,java.util.regex.matcher.group,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.in,java.lang.system.out,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.in,java.lang.system.err,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.in,java.lang.system.setout,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.in,java.lang.system.seterr,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.out,java.lang.system.setin,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.out,java.lang.system.seterr,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.err,java.lang.system.setin,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.err,java.lang.system.setout,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.err,java.lang.system.seterr,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.setin,java.lang.system.setout,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Normally, final static fields may not be modified. However System.in, System.out, and System.err are final static fields that, for legacy reasons, must be allowed to be changed by the methods System.setIn, System.setOut and System.setErr. We refer to these fields as being write-protected to distinguish them from ordinary final fields.",java.lang.system.setout,java.lang.system.seterr,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"Basically, DateFormat sets Calendar.setLenient and the Javadoc states:",java.text.dateformat,java.util.calendar.setlenient,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Using it is straightforward: just provide extra parameter to Instant.now(), or call Clock.instant() directly:",java.time.instant.now,java.time.clock.instant,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The assignment operator in Java evaluates to the assigned value (like it does in, e.g., c). So here, readLine() will be executed, and its return value stored in line. That stored value is then checked against null, and if it's null then the loop will terminate.",java.io.bufferedreader.readline,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The assignment operator in Java evaluates to the assigned value (like it does in, e.g., c). So here, readLine() will be executed, and its return value stored in line. That stored value is then checked against null, and if it's null then the loop will terminate.",java.io.bufferedreader.readline,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"The assignment operator in Java evaluates to the assigned value (like it does in, e.g., c). So here, readLine() will be executed, and its return value stored in line. That stored value is then checked against null, and if it's null then the loop will terminate.",java.lang.string,java.lang.object,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.multimaps.invertfrom,com.google.common.collect.immutablemultimap,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.multimaps.invertfrom,com.google.common.collect.immutablelistmultimap,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.multimaps.invertfrom,com.google.common.collect.immutablesetmultimap,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.multimaps.invertfrom,com.google.common.collect.sets.immutableenumset,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.immutablemultimap,com.google.common.collect.immutablelistmultimap,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.immutablemultimap,com.google.common.collect.immutablesetmultimap,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.immutablemultimap,com.google.common.collect.sets.immutableenumset,"[('no', 'no', 'yes', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.immutablelistmultimap,com.google.common.collect.immutablesetmultimap,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.immutablelistmultimap,com.google.common.collect.sets.immutableenumset,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"If your ""BiMultimap"" is going to immutable constant - use Multimaps.invertFrom and ImmutableMultimap / ImmutableListMultimap / ImmutableSetMultimap (each of theese three has different collection storing values). Some code (example taken from app I develop, uses Enums and Sets.immutableEnumSet):",com.google.common.collect.immutablesetmultimap,com.google.common.collect.sets.immutableenumset,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, &amp; SimpleDateFormat.",java.time,java.text.simpledateformat.,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, &amp; SimpleDateFormat.",java.util.date,java.text.simpledateformat.,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, &amp; SimpleDateFormat.",java.util.calendar,java.text.simpledateformat.,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"As suggested here, a custom renderer can query the model to condition the result returned by getItemPaint(). In this example, subtasks are rendered using a palette of varying saturations of the default color for a given series. The approach assumes that the renderer makes two passes; some care should be given to documenting the dependency.",org.jfree.chart.renderer.abstractrenderer.getitempaint,org.jfree.chart.renderer.renderer,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"As suggested here, a custom renderer can query the model to condition the result returned by getItemPaint(). In this example, subtasks are rendered using a palette of varying saturations of the default color for a given series. The approach assumes that the renderer makes two passes; some care should be given to documenting the dependency.",org.jfree.chart.renderer.abstractrenderer.getitempaint,java.awt.palette,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"As suggested here, a custom renderer can query the model to condition the result returned by getItemPaint(). In this example, subtasks are rendered using a palette of varying saturations of the default color for a given series. The approach assumes that the renderer makes two passes; some care should be given to documenting the dependency.",org.jfree.chart.renderer.abstractrenderer.getitempaint,org.jfree.data.general.series.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"As suggested here, a custom renderer can query the model to condition the result returned by getItemPaint(). In this example, subtasks are rendered using a palette of varying saturations of the default color for a given series. The approach assumes that the renderer makes two passes; some care should be given to documenting the dependency.",org.jfree.chart.renderer.renderer,java.awt.palette,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"As suggested here, a custom renderer can query the model to condition the result returned by getItemPaint(). In this example, subtasks are rendered using a palette of varying saturations of the default color for a given series. The approach assumes that the renderer makes two passes; some care should be given to documenting the dependency.",org.jfree.chart.renderer.renderer,org.jfree.data.general.series.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"As suggested here, a custom renderer can query the model to condition the result returned by getItemPaint(). In this example, subtasks are rendered using a palette of varying saturations of the default color for a given series. The approach assumes that the renderer makes two passes; some care should be given to documenting the dependency.",java.awt.palette,org.jfree.data.general.series.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Modify the above code so that the ""columnNames"" Vector contains another header name for the check box column and add Boolean.FALSE to each ""row"" Vector as you iterate through the ResultSet.",java.util.vector,java.lang.boolean.false,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The quickest way to get the ""first"" entry is still entrySet().iterator().next(). Getting the ""last"" entry is possible, but will entail iterating over the whole entry set by calling .next() until you reach the last.  while (iterator.hasNext()) { lastElement = iterator.next() }",java.util.map.entryset,java.util.iterator.iterator,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"The quickest way to get the ""first"" entry is still entrySet().iterator().next(). Getting the ""last"" entry is possible, but will entail iterating over the whole entry set by calling .next() until you reach the last.  while (iterator.hasNext()) { lastElement = iterator.next() }",java.util.map.entryset,java.util.iterator.next,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The quickest way to get the ""first"" entry is still entrySet().iterator().next(). Getting the ""last"" entry is possible, but will entail iterating over the whole entry set by calling .next() until you reach the last.  while (iterator.hasNext()) { lastElement = iterator.next() }",java.util.map.entryset,java.util.iterator.hasnext,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The quickest way to get the ""first"" entry is still entrySet().iterator().next(). Getting the ""last"" entry is possible, but will entail iterating over the whole entry set by calling .next() until you reach the last.  while (iterator.hasNext()) { lastElement = iterator.next() }",java.util.iterator.iterator,java.util.iterator.next,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The quickest way to get the ""first"" entry is still entrySet().iterator().next(). Getting the ""last"" entry is possible, but will entail iterating over the whole entry set by calling .next() until you reach the last.  while (iterator.hasNext()) { lastElement = iterator.next() }",java.util.iterator.iterator,java.util.iterator.hasnext,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Please get rid of those scriptlets in your JSP. The  request.setCharacterEncoding(""UTF-8""); is called at the wrong moment. It would be too late whenever you've properly used a Servlet to process the request. You'd rather like to use a filter for this. The  response.setCharacterEncoding(""UTF-8""); part is already implicitly done by pageEncoding=""UTF-8"" in top of JSP.",javax.servlet.http.httpservletrequest.setcharacterencoding,javax.servlet.http.httpservletresponse.setcharacterencoding,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"It's a general rule that floating point number should never be compared like (a==b), but rather like (Math.abs(a-b) &lt; delta) where delta is a small number.",java.lang.float,java.lang.math.abs,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"then you create new ArrayList, which is a full, independent copy of the original one. Although here you create the wrapper using Arrays.asList as well, it is used only during the construction of the new ArrayList and is garbage-collected afterwards. The structure of this new ArrayList is completely independent of the original array. It contains the same elements (both the original array and this new ArrayList reference the same integers in memory), but it creates a new, internal array, that holds the references. So when you shuffle it, add, remove elements etc., the original array is unchanged.",java.util.arraylist,java.util.arrays.aslist,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Basically, I think you have a good understanding of how this works, so let me just reiterate in layman's terms. getOutputStream basically opens a connection stream, with the intention of writing data to the server. In the above code example ""message"" could be a comment that we're sending to the server that represents a comment left on a post. When you see getOutputStream, you're opening the connection stream for writing, but you don't actually write any data until you call writer.write(""message="" + message);.",java.net.urlconnection.getoutputstream,java.io.writer.write,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"That being said, it doesn't seem like it would be too difficult to achieve something similar to what you are describing. For instance, you might consider implementing your searchable-Activity so that it will accept the android.intent.action.SEARCH intent and (instead of immediately displaying the results in a ListView, for example) will pass the search query to your Fragments. For instance, consider the following searchable Activity:",android.content.intent.action_search,android.widget.listview,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"That being said, it doesn't seem like it would be too difficult to achieve something similar to what you are describing. For instance, you might consider implementing your searchable-Activity so that it will accept the android.intent.action.SEARCH intent and (instead of immediately displaying the results in a ListView, for example) will pass the search query to your Fragments. For instance, consider the following searchable Activity:",android.content.intent.action_search,android.app.fragment,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"That being said, it doesn't seem like it would be too difficult to achieve something similar to what you are describing. For instance, you might consider implementing your searchable-Activity so that it will accept the android.intent.action.SEARCH intent and (instead of immediately displaying the results in a ListView, for example) will pass the search query to your Fragments. For instance, consider the following searchable Activity:",android.widget.listview,android.app.fragment,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
See javax.imageio package for more info.  That's using the AWT image.  Otherwise you could do:,javax.imageio,javax.imageio.package,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
See javax.imageio package for more info.  That's using the AWT image.  Otherwise you could do:,javax.imageio,java.awt.image.image,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
See javax.imageio package for more info.  That's using the AWT image.  Otherwise you could do:,javax.imageio.package,java.awt.image.image,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Calling Socket.close() on the socket will close the associated InputStream and OutputStream objects, and cause any threads blocked in Socket or (associated) stream  operations to be unblocked.  According to the javadoc, operations on the socket itself will throw a SocketException.",java.net.socket.close,java.net.socket,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Calling Socket.close() on the socket will close the associated InputStream and OutputStream objects, and cause any threads blocked in Socket or (associated) stream  operations to be unblocked.  According to the javadoc, operations on the socket itself will throw a SocketException.",java.net.socket.close,java.net.socketexception,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Calling Socket.close() on the socket will close the associated InputStream and OutputStream objects, and cause any threads blocked in Socket or (associated) stream  operations to be unblocked.  According to the javadoc, operations on the socket itself will throw a SocketException.",java.net.socket,java.net.socketexception,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"For those unfamiliar with streams, what this does is gets an IntStream from 0 to the length, then boxes it, making it a Stream&lt;Integer&gt; so that it can be transformed into an object, then collects them using Collectors.toMap which takes two suppliers, one of which generates the keys, the other the values.",java.util.stream.intstream,java.util.stream.stream&lt;integer&gt;,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"For those unfamiliar with streams, what this does is gets an IntStream from 0 to the length, then boxes it, making it a Stream&lt;Integer&gt; so that it can be transformed into an object, then collects them using Collectors.toMap which takes two suppliers, one of which generates the keys, the other the values.",java.util.stream.intstream,java.util.stream.collectors.tomap,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"For those unfamiliar with streams, what this does is gets an IntStream from 0 to the length, then boxes it, making it a Stream&lt;Integer&gt; so that it can be transformed into an object, then collects them using Collectors.toMap which takes two suppliers, one of which generates the keys, the other the values.",java.util.stream.stream&lt;integer&gt;,java.util.stream.collectors.tomap,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'yes', 'yes')]"
"Updated: As mentioned by Stuart MarksArrays.stream is preferable to using Stream.of(array).skip(n).limit(m) because the former results in a SIZED stream whereas the latter does not. The reason is that limit(m) doesn't know whether the size is m or less than m, whereas Arrays.streamArrays.stream(array,start,end) here, whereas for stream implementation returned by Stream.of(array).skip().limit() is within this method.",java.util.arrays.stream,java.util.stream.stream.of,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"System.getProperty(""java.version"") returns what you need. ",java.lang.system.getproperty,java.version,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
You could also try using Class.forName(String) to force the JVM to load the class and invoke its static blocks.,java.lang.class.forname,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
or programmatically by SessionCookieConfig which is available by ServletContext#getSessionCookieConfig().,javax.servlet.sessioncookieconfig,javax.servlet.servletcontext.getsessioncookieconfig,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You could do this in ServletContextListener#contextInitialized() or HttpServlet#init().,javax.servlet.servletcontextlistener.contextinitialized,javax.servlet.http.httpservlet.init,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
Get the SSLSession from your SSLSocket on your client and use its getProtocol() method.,javax.net.ssl.sslsession,javax.net.ssl.sslsocket,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
Get the SSLSession from your SSLSocket on your client and use its getProtocol() method.,javax.net.ssl.sslsession,javax.net.ssl.sslsession.getprotocol,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
Get the SSLSession from your SSLSocket on your client and use its getProtocol() method.,javax.net.ssl.sslsocket,javax.net.ssl.sslsession.getprotocol,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"The get() operation returns a Task&lt;&gt; which means it is an asynchronous operation.  Calling getListItems() only starts the operation, it does not wait for it to complete, that's why you have to add success and failure listeners.",java.util.concurrent.future.get,java.util.concurrent.task,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The get() operation returns a Task&lt;&gt; which means it is an asynchronous operation.  Calling getListItems() only starts the operation, it does not wait for it to complete, that's why you have to add success and failure listeners.",java.util.concurrent.future.get,java.util.concurrent.future.getlistitems,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"The get() operation returns a Task&lt;&gt; which means it is an asynchronous operation.  Calling getListItems() only starts the operation, it does not wait for it to complete, that's why you have to add success and failure listeners.",java.util.concurrent.task,java.util.concurrent.future.getlistitems,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"To start off, write an abstract TypeAdapterFactory that gives you hooks to modify the outgoing data. This example uses a new API in Gson 2.2 called getDelegateAdapter() that allows you to look up the adapter that Gson would use by default. The delegate adapters are extremely handy if you just want to tweak the standard behavior. And unlike full custom type adapters, they'll stay up-to-date automatically as you add and remove fields.",com.google.gson.typeadapterfactory,com.google.gson.gson.getdelegateadapter,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"To start off, write an abstract TypeAdapterFactory that gives you hooks to modify the outgoing data. This example uses a new API in Gson 2.2 called getDelegateAdapter() that allows you to look up the adapter that Gson would use by default. The delegate adapters are extremely handy if you just want to tweak the standard behavior. And unlike full custom type adapters, they'll stay up-to-date automatically as you add and remove fields.",com.google.gson.typeadapterfactory,com.google.gson.gson,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"To start off, write an abstract TypeAdapterFactory that gives you hooks to modify the outgoing data. This example uses a new API in Gson 2.2 called getDelegateAdapter() that allows you to look up the adapter that Gson would use by default. The delegate adapters are extremely handy if you just want to tweak the standard behavior. And unlike full custom type adapters, they'll stay up-to-date automatically as you add and remove fields.",com.google.gson.typeadapterfactory,com.google.gson.typeadapter,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"To start off, write an abstract TypeAdapterFactory that gives you hooks to modify the outgoing data. This example uses a new API in Gson 2.2 called getDelegateAdapter() that allows you to look up the adapter that Gson would use by default. The delegate adapters are extremely handy if you just want to tweak the standard behavior. And unlike full custom type adapters, they'll stay up-to-date automatically as you add and remove fields.",com.google.gson.gson.getdelegateadapter,com.google.gson.gson,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"To start off, write an abstract TypeAdapterFactory that gives you hooks to modify the outgoing data. This example uses a new API in Gson 2.2 called getDelegateAdapter() that allows you to look up the adapter that Gson would use by default. The delegate adapters are extremely handy if you just want to tweak the standard behavior. And unlike full custom type adapters, they'll stay up-to-date automatically as you add and remove fields.",com.google.gson.gson.getdelegateadapter,com.google.gson.typeadapter,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"To start off, write an abstract TypeAdapterFactory that gives you hooks to modify the outgoing data. This example uses a new API in Gson 2.2 called getDelegateAdapter() that allows you to look up the adapter that Gson would use by default. The delegate adapters are extremely handy if you just want to tweak the standard behavior. And unlike full custom type adapters, they'll stay up-to-date automatically as you add and remove fields.",com.google.gson.gson,com.google.gson.typeadapter,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"I've only ever used Class.cast(Object) to avoid warnings in ""generics land"". I often see methods doing things like this:",java.lang.class.cast,java.lang.class,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
Regarding compiler warnings: I suspect that Class.cast(Object) isn't special to the compiler. It could be optimized when used statically (i.e. Foo.class.cast(o) rather than cls.cast(o)) but I've never seen anybody using it - which makes the effort of building this optimization into the compiler somewhat worthless.,java.lang.class.cast,java.lang.class.class,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
Regarding compiler warnings: I suspect that Class.cast(Object) isn't special to the compiler. It could be optimized when used statically (i.e. Foo.class.cast(o) rather than cls.cast(o)) but I've never seen anybody using it - which makes the effort of building this optimization into the compiler somewhat worthless.,java.lang.class.class,java.lang.class.cast,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"It will throw a FileNotFoundException if the file doesn't exist and cannot be created (doc), but it will create it if it can. To be sure you probably should first test that the file exists before you create the FileOutputStream (and create with createNewFile() if it doesn't):",java.io.filenotfoundexception,java.io.fileoutputstream,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"It will throw a FileNotFoundException if the file doesn't exist and cannot be created (doc), but it will create it if it can. To be sure you probably should first test that the file exists before you create the FileOutputStream (and create with createNewFile() if it doesn't):",java.io.filenotfoundexception,java.io.file.createnewfile,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"It will throw a FileNotFoundException if the file doesn't exist and cannot be created (doc), but it will create it if it can. To be sure you probably should first test that the file exists before you create the FileOutputStream (and create with createNewFile() if it doesn't):",java.io.fileoutputstream,java.io.file.createnewfile,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"This problem happens because Android Platform (android.jar) already contains JUnit classes. IDEA test runner loads these classes and sees that they are from the old JUnit, while you are trying to use annotated tests which is a feature of the new JUnit, therefore you get the error from the test runner.",android.jar,junit.framework.junit,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"There are three libraries mentioned on the Arbitrary Precision Arithmetic page: java.math (containing the mentioned BigDecimal), Apfloat and JScience. I run a little speed check on them which just uses addition and multiplication. ",java.math,java.math.bigdecimal,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"There are three libraries mentioned on the Arbitrary Precision Arithmetic page: java.math (containing the mentioned BigDecimal), Apfloat and JScience. I run a little speed check on them which just uses addition and multiplication. ",java.math,org.apfloat.apfloat,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"There are three libraries mentioned on the Arbitrary Precision Arithmetic page: java.math (containing the mentioned BigDecimal), Apfloat and JScience. I run a little speed check on them which just uses addition and multiplication. ",java.math,org.jscience.mathematics.number.largeinteger,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"There are three libraries mentioned on the Arbitrary Precision Arithmetic page: java.math (containing the mentioned BigDecimal), Apfloat and JScience. I run a little speed check on them which just uses addition and multiplication. ",java.math.bigdecimal,org.apfloat.apfloat,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"There are three libraries mentioned on the Arbitrary Precision Arithmetic page: java.math (containing the mentioned BigDecimal), Apfloat and JScience. I run a little speed check on them which just uses addition and multiplication. ",java.math.bigdecimal,org.jscience.mathematics.number.largeinteger,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"There are three libraries mentioned on the Arbitrary Precision Arithmetic page: java.math (containing the mentioned BigDecimal), Apfloat and JScience. I run a little speed check on them which just uses addition and multiplication. ",org.apfloat.apfloat,org.jscience.mathematics.number.largeinteger,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"And no matter if you use Class.forName() or the new service provider mechanism, you will always need the JDBC driver on the classpath (or available via some ClassLoader at runtime, at least).",java.lang.class.forname,java.sql.driver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Ex: Toast.maketext(getActivity(), ""..."", Toast.LENGTH_LONG).show();",android.widget.toast.maketext,android.widget.toast.length_long,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Once you have your objects as Paths, you can draw them directly using drawPath(). You can also perform movement by transform()ing the path.",java.nio.file.paths,android.graphics.path.drawpath,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"Once you have your objects as Paths, you can draw them directly using drawPath(). You can also perform movement by transform()ing the path.",java.nio.file.paths,android.graphics.matrix.transform,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Once you have your objects as Paths, you can draw them directly using drawPath(). You can also perform movement by transform()ing the path.",android.graphics.path.drawpath,android.graphics.matrix.transform,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"The second is the implementation of equals for the constraint violation (javax.validation.Validator.validate() returns a set!). When you are always putting in the same message (should be one of [a, b]), the set will still contain only 1 element. As a solution you could prepend the current value to the message (class CoBoundedStringConstraints):",java.lang.object.equals,javax.validation.validator.validate,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
You need to use IPackageStatsObserver.aidl and have to invoke getPackageSizeInfo method by reflection.,android.content.pm.ipackagestatsobserver.aidl,android.content.pm.ipackagemanager.getpackagesizeinfo,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"If you can, use something like Java 6's Console or Swing's JPasswordField to get a password. These return an array, so you can ""delete"" the password from memory when you are done with it: Arrays.fill(password, '\0');",java.io.console,javax.swing.jpasswordfield,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"If you can, use something like Java 6's Console or Swing's JPasswordField to get a password. These return an array, so you can ""delete"" the password from memory when you are done with it: Arrays.fill(password, '\0');",java.io.console,java.util.arrays.fill,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"If you can, use something like Java 6's Console or Swing's JPasswordField to get a password. These return an array, so you can ""delete"" the password from memory when you are done with it: Arrays.fill(password, '\0');",javax.swing.jpasswordfield,java.util.arrays.fill,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent.gettext,javax.swing.text.jtextcomponent,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent.gettext,javax.swing.text.jtextpane,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent.gettext,javax.swing.text.jeditorpane,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent.gettext,javax.swing.text.editorkit,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent.gettext,java.io.stringwriter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent,javax.swing.text.jtextpane,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent,javax.swing.text.jeditorpane,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent,javax.swing.text.editorkit,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextcomponent,java.io.stringwriter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextpane,javax.swing.text.jeditorpane,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextpane,javax.swing.text.editorkit,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jtextpane,java.io.stringwriter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jeditorpane,javax.swing.text.editorkit,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.jeditorpane,java.io.stringwriter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
A JTextComponent's getText() and A JTextPane/JEditorPane's getText() has different implementation. JTextPane/JEditorPane uses EditorKit to write the document content(text) to a StringWriter and then return the text with  formatting and inserting a line/paragraph break into the document. But the JTextCompoent returns document content directly by:,javax.swing.text.editorkit,java.io.stringwriter,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
You will better understand if you try to compare the length : jTextPane1.getText().length() and jTextPane1().getDocument().getLength().,javax.swing.jtextpane.gettext.length,javax.swing.jtextpane.getdocument.getlength,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
Where did you get this extremely odd approach using getRuntime().exec()? Here's an easy working code sample for you using SharedPreferences. Replace your whole switch-statement with this one:,java.lang.runtime.getruntime.exec,android.content.sharedpreferences,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Finally, when you make a Matcher, the Matcher potentially makes more copies of this 600 MB CharBuffer, depending on how you use it.  Ouch.  That's a lot of memory used by a small number of objects!  Given a Matcher, every time you call toMatchResult(), you'll make a String copy of the entire CharBuffer.  Also, every time you call replaceAll(), at best you will make a String copy of the entire CharBuffer.  At worst you will make a StringBuffer that will slowly be expanded to the full size of the replaceAll result (applying a lot of memory pressure on the heap), and then make a String from that.",java.util.regex.matcher,java.util.regex.matcher.tomatchresult,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Finally, when you make a Matcher, the Matcher potentially makes more copies of this 600 MB CharBuffer, depending on how you use it.  Ouch.  That's a lot of memory used by a small number of objects!  Given a Matcher, every time you call toMatchResult(), you'll make a String copy of the entire CharBuffer.  Also, every time you call replaceAll(), at best you will make a String copy of the entire CharBuffer.  At worst you will make a StringBuffer that will slowly be expanded to the full size of the replaceAll result (applying a lot of memory pressure on the heap), and then make a String from that.",java.util.regex.matcher,java.util.regex.matcher.replaceall,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Finally, when you make a Matcher, the Matcher potentially makes more copies of this 600 MB CharBuffer, depending on how you use it.  Ouch.  That's a lot of memory used by a small number of objects!  Given a Matcher, every time you call toMatchResult(), you'll make a String copy of the entire CharBuffer.  Also, every time you call replaceAll(), at best you will make a String copy of the entire CharBuffer.  At worst you will make a StringBuffer that will slowly be expanded to the full size of the replaceAll result (applying a lot of memory pressure on the heap), and then make a String from that.",java.util.regex.matcher.tomatchresult,java.util.regex.matcher.replaceall,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"The button's action, which is invoked whenever the button is fired. This may be due to the user clicking on the button with the mouse, or by a touch event, or by a key press, or if the developer programmatically invokes the fire() method.",javafx.scene.control.button.action,javafx.scene.control.button.fire,"[('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"If the exception caught by the servletcontainer is a ServletException and the &lt;error-page&gt; is declared to catch an exception other than ServletException, then its cause will actually be unwrapped and stored as ""javax.servlet.error.exception"". So you basically already have it as throwable variable and you don't need to call getCause() on it.",javax.servlet.servletexception,javax.servlet.error.exception,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"If the exception caught by the servletcontainer is a ServletException and the &lt;error-page&gt; is declared to catch an exception other than ServletException, then its cause will actually be unwrapped and stored as ""javax.servlet.error.exception"". So you basically already have it as throwable variable and you don't need to call getCause() on it.",javax.servlet.servletexception,java.lang.throwable,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"If the exception caught by the servletcontainer is a ServletException and the &lt;error-page&gt; is declared to catch an exception other than ServletException, then its cause will actually be unwrapped and stored as ""javax.servlet.error.exception"". So you basically already have it as throwable variable and you don't need to call getCause() on it.",javax.servlet.error.exception,java.lang.throwable,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
You can call Thread.getState() on and check if the state is TIMED_WAITING.,java.lang.thread.getstate,java.lang.thread.state.timed_waiting,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
Those are not regular files nor directories nor symlinks so both File.isFile() and File.isDirectory() will return false while File.exists() will return true. For example /dev/null (on Unix compatible OSes) is a device file.,java.io.file.isfile,java.io.file.isdirectory,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
Those are not regular files nor directories nor symlinks so both File.isFile() and File.isDirectory() will return false while File.exists() will return true. For example /dev/null (on Unix compatible OSes) is a device file.,java.io.file.isfile,java.io.file.exists,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Those are not regular files nor directories nor symlinks so both File.isFile() and File.isDirectory() will return false while File.exists() will return true. For example /dev/null (on Unix compatible OSes) is a device file.,java.io.file.isdirectory,java.io.file.exists,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.exists,java.io.file.isfile,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.exists,java.io.file.isdirectory,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.exists,java.lang.runtime.access,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.exists,java.lang.runtime.stat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.isfile,java.lang.runtime.access,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.isfile,java.lang.runtime.stat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.isdirectory,java.lang.runtime.access,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.io.file.isdirectory,java.lang.runtime.stat,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
Eg. on Android File.exists() is implemented using access() system call while File.isFile()/File.isDirectory() use stat(). In this case processing stat() output requires more logic in userspace than access().,java.lang.runtime.access,java.lang.runtime.stat,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints:",java.util.stream.collector,java.util.stream.stream.collect,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes')]"
"If you can use external libraries, take a look at Guava's MapMaker.makeComputingMap(). It's tailor-made for what you're trying to do.",com.google.common.collect.mapmaker.makecomputingmap,com.google.common.collect.mapmaker,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
See: JavaSE 6 java.lang.StringBuffer capacity(),java.lang.stringbuffer,java.lang.stringbuffer.capacity,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
You will need to have ValueActivity implement Parcelable interface and you will need to implement writeToParcel() the CREATOR and a suitable constructor that takes a Parcel as argument. See the documentation of Parcelable interface.,android.os.parcelable,android.os.parcelable.writetoparcel,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
You will need to have ValueActivity implement Parcelable interface and you will need to implement writeToParcel() the CREATOR and a suitable constructor that takes a Parcel as argument. See the documentation of Parcelable interface.,android.os.parcelable,android.os.parcelable.creator,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You will need to have ValueActivity implement Parcelable interface and you will need to implement writeToParcel() the CREATOR and a suitable constructor that takes a Parcel as argument. See the documentation of Parcelable interface.,android.os.parcelable,android.os.parcel,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
You will need to have ValueActivity implement Parcelable interface and you will need to implement writeToParcel() the CREATOR and a suitable constructor that takes a Parcel as argument. See the documentation of Parcelable interface.,android.os.parcelable.writetoparcel,android.os.parcelable.creator,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You will need to have ValueActivity implement Parcelable interface and you will need to implement writeToParcel() the CREATOR and a suitable constructor that takes a Parcel as argument. See the documentation of Parcelable interface.,android.os.parcelable.writetoparcel,android.os.parcel,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
You will need to have ValueActivity implement Parcelable interface and you will need to implement writeToParcel() the CREATOR and a suitable constructor that takes a Parcel as argument. See the documentation of Parcelable interface.,android.os.parcelable.creator,android.os.parcel,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"The problem was resolved (with some open suspicions about the suitability of nanoTime() on multi-core systems!) by adding /usepmtimer to the end of my C:\boot.ini string; forcing Windows to use the Power Management timer rather than the TSC. It's an open question as to why I needed to do this given I'm on XP SP3, as I understood that this was the default, however perhaps it was due to the manner in which my machine was patched to SP3.",java.lang.system.nanotime,java.lang.powermanagementtimer,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"The problem was resolved (with some open suspicions about the suitability of nanoTime() on multi-core systems!) by adding /usepmtimer to the end of my C:\boot.ini string; forcing Windows to use the Power Management timer rather than the TSC. It's an open question as to why I needed to do this given I'm on XP SP3, as I understood that this was the default, however perhaps it was due to the manner in which my machine was patched to SP3.",java.lang.system.nanotime,java.lang.tsc,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The problem was resolved (with some open suspicions about the suitability of nanoTime() on multi-core systems!) by adding /usepmtimer to the end of my C:\boot.ini string; forcing Windows to use the Power Management timer rather than the TSC. It's an open question as to why I needed to do this given I'm on XP SP3, as I understood that this was the default, however perhaps it was due to the manner in which my machine was patched to SP3.",java.lang.powermanagementtimer,java.lang.tsc,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"So, since rawAlpha is a raw type, the type of rawAlpha.intList is the erasure of List&lt;Integer&gt; intList(). That erasure is List intList().",java.util.list,java.util.list.intlist,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"Also there is no explicit ""mouse pressed"" notion in MouseEvent, so you must track that yourself.  I have provided an example of how to do this.  Also note the MouseEvent.BUTTON1 references, as this is just to track the state of the left mouse button.",java.awt.event.mouseevent,java.awt.event.mouseevent.button1,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Use ServletContext#getRealPath() to translate a relative web path to an absolute disk file system path. The ServletContext is available in the servlet by the inherited getServletContext() method. Thus, following should point out the right file:",javax.servlet.servletcontext#getrealpath,javax.servlet.servlet.getservletcontext,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"If you replace .count() with Java 8-style implementation .mapToLong(e -&gt; 1L).sum(), it will be slow again even on JDK 9.",java.util.stream.stream.count,java.util.stream.stream.maptolong,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"If you replace .count() with Java 8-style implementation .mapToLong(e -&gt; 1L).sum(), it will be slow again even on JDK 9.",java.util.stream.stream.count,java.util.stream.stream.sum,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"If you replace .count() with Java 8-style implementation .mapToLong(e -&gt; 1L).sum(), it will be slow again even on JDK 9.",java.util.stream.stream.maptolong,java.util.stream.stream.sum,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"resource.getSubResourceMethods() == getChildResources(), which actually just returns a List&lt;Resource&gt;",javax.ws.rs.core.resource.getsubresourcemethods,javax.ws.rs.core.resource.getchildresources,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"resource.getSubResourceMethods() == getChildResources(), which actually just returns a List&lt;Resource&gt;",javax.ws.rs.core.resource.getsubresourcemethods,java.util.list&lt;javax.ws.rs.core.resource,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"resource.getSubResourceMethods() == getChildResources(), which actually just returns a List&lt;Resource&gt;",javax.ws.rs.core.resource.getchildresources,java.util.list&lt;javax.ws.rs.core.resource&gt;,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"You are assuming that write() succeeded completely, and you're ignoring the count it returns.",java.io.outputstream.write,java.io.outputstream.count,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
To wrap a class you have to inject a play.data.FormFactory into your Controller which then allows you to create the form:,play.data.formfactory,play.mvc.controller,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"This works because BigDecimal maintains a ""precision,"" and the BigDecimal(String) constructor sets that from the number of digits to the right of the ., and uses it in toString. So if you just dump it out with System.out.println(decimal);, it prints out 12.00.",java.math.bigdecimal,java.lang.system.out.println,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"This works because BigDecimal maintains a ""precision,"" and the BigDecimal(String) constructor sets that from the number of digits to the right of the ., and uses it in toString. So if you just dump it out with System.out.println(decimal);, it prints out 12.00.",java.math.bigdecimal,java.lang.object.tostring,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"In previous versions of Spring (before 4.0), QualifierAnnotationAutowireCandidateResolver was set during creation of most ApplicationContexts (compare AbstractRefreshableApplicationContext.customizeBeanFactory(DefaultListableBeanFactory) implementations). ",org.springframework.beans.factory.annotation.qualifierannotationautowirecandidateresolver,org.springframework.context.support.abstractrefreshableapplicationcontext.customizebeanfactory,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"In previous versions of Spring (before 4.0), QualifierAnnotationAutowireCandidateResolver was set during creation of most ApplicationContexts (compare AbstractRefreshableApplicationContext.customizeBeanFactory(DefaultListableBeanFactory) implementations). ",org.springframework.beans.factory.annotation.qualifierannotationautowirecandidateresolver,org.springframework.beans.factory.support.defaultlistablebeanfactory,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"In previous versions of Spring (before 4.0), QualifierAnnotationAutowireCandidateResolver was set during creation of most ApplicationContexts (compare AbstractRefreshableApplicationContext.customizeBeanFactory(DefaultListableBeanFactory) implementations). ",org.springframework.context.support.abstractrefreshableapplicationcontext.customizebeanfactory,org.springframework.beans.factory.support.defaultlistablebeanfactory,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.spec.x509encodedkeyspec,java.security.keyfactory,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.spec.x509encodedkeyspec,java.security.interfaces.rsapublickey,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.spec.x509encodedkeyspec,java.math.biginteger.tobytearray,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.spec.x509encodedkeyspec,0x02,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.spec.x509encodedkeyspec,0x30,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.keyfactory,java.security.interfaces.rsapublickey,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.keyfactory,java.math.biginteger.tobytearray,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.keyfactory,0x02,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.keyfactory,0x30,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.interfaces.rsapublickey,java.math.biginteger.tobytearray,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.interfaces.rsapublickey,0x02,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.security.interfaces.rsapublickey,0x30,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.math.biginteger.tobytearray,0x02,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",java.math.biginteger.tobytearray,0x30,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Or use standard JCE to read the X.509 format key: wrap the bytes in an X509EncodedKeySpec, give it to .generatePublic() of a KeyFactory for RSA, and cast the result to RSAPublicKey. Then call .getModulus() and .getPublicExponent() to get the mathematical values and encode them in ASN.1 DER with the structure RSAPublicKey defined in PKCS#1 rfc3447 (used for PKIX/X.509 in rfc3279 2.2.1). BigInteger.toByteArray().toByteArray() values, add tag=INTEGER (0x02) and length prefixes to each one, then add a tag=SEQUENCE-composite (0x30) and length prefix to their concatenation. Then proceed to step 3.",0x02,0x30,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Streams.asString takes a second parameter which is the charset encoding to use, you might need to specify one that is suitable for your site.",org.apache.commons.io.ioutils.asstring,java.nio.charset.charset,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"An instance of java.awt.TexturePaint provides a convenient way to tile a BufferedImage. Related examples may be seen here. Given a TexturePaint, you can fill a component's background fairly easily, as shown here.",java.awt.texturepaint,java.awt.image.bufferedimage,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"An instance of java.awt.TexturePaint provides a convenient way to tile a BufferedImage. Related examples may be seen here. Given a TexturePaint, you can fill a component's background fairly easily, as shown here.",java.awt.texturepaint,java.awt.graphics.fill,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"An instance of java.awt.TexturePaint provides a convenient way to tile a BufferedImage. Related examples may be seen here. Given a TexturePaint, you can fill a component's background fairly easily, as shown here.",java.awt.image.bufferedimage,java.awt.texturepaint,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"An instance of java.awt.TexturePaint provides a convenient way to tile a BufferedImage. Related examples may be seen here. Given a TexturePaint, you can fill a component's background fairly easily, as shown here.",java.awt.image.bufferedimage,java.awt.graphics.fill,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"So basically, this is a function that gets a LoopPipe.LoopBundle as an object which contains metadata about the loop and expects that you return a boolean value.  If you understand that concept, then all of Gremlin Java opens up for you, because everywhere that you see a groovy closure, you know that underneath it is just some form of PipeFunction in java and given that you can now read the expectations of a PipeFunction from the javadocs, it should be straightforward to do these language translations.  ",org.apache.tinkerpop.gremlin.process.traversal.step.util.event.looppipe.loopbundle,org.apache.tinkerpop.gremlin.process.traversal.util.pipefunction,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
Found a solution. I switched Java to use the G1 garbage collector and now the HeapFreeRatio parameters works as intended. So I use these options in eclipse.ini:,java.lang.management.garbagecollectormxbean.g1,java.lang.management.memoryusage.heapfreeratio,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
Or pass an instance of java.util.Properties to PigServer constructor.,java.util.properties,org.apache.pig.pigserver,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduleinfo,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.modulefinder,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.modulereference,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.configuration,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.resolvedmodule,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.modulereader,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",org.apache.maven.plugins.compiler.mavencompilerplugin,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.modulefinder,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.modulereference,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.configuration,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.resolvedmodule,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.modulereader,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduleinfo,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.modulefinder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.modulereference,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.configuration,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.resolvedmodule,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.modulereader,"[('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.requires,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.exports,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.opens,"[('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.uses,"[('yes', 'yes', 'no', 'yeso'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.packages,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.builder,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.version.name,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.version.modifier,"[('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.modulereference,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.configuration,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.resolvedmodule,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.modulereader,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulefinder,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.configuration,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.resolvedmodule,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.modulereader,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereference,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.resolvedmodule,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.modulereader,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.configuration,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.modulereader,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.resolvedmodule,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.version,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.modulereader,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.requires,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.version.name,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.exports,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.uses,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.provides,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.opens,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.packages,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.exports,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.opens,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.provides,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.uses,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.packages,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.opens,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.uses,java.lang.module.moduledescriptor.packages,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.uses,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.uses,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.uses,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.uses,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.uses,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.packages,java.lang.module.moduledescriptor.builder,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.packages,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.packages,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.packages,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.packages,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.builder,java.lang.module.moduledescriptor.version.name,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.builder,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.builder,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.builder,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version.name,java.lang.module.moduledescriptor.version.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version.name,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version.name,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version.modifier,java.lang.module.moduledescriptor.requires.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.version.modifier,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"maven-compiler-plugin 3.6.0 is based on the first signature of module-info.class, which has changed a couple of times. It is not compatible with current Java 9 signature. You should use 3.6.2 when using most recent versions of JDK 9.",java.lang.module.moduledescriptor.requires.modifier,java.lang.module.moduledescriptor.exports.modifier,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'yes', 'yes')]"
Your thread is finishing immediately because it does not have a run() method defined so it is started and finishes.  Really it is a race condition and the thread that is started could finish before the main thread gets to the wait() method call.  You can see this if you put a short sleep (maybe 10ms) after the start() is called.  Then you can see that you program will sit in wait() forever.,java.lang.thread.run,java.lang.object.wait,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"As solution: try to check if getIntent().getExtras() != null before getting the data, this will fix your problem.",android.content.intent.getintent,android.content.intent.getextras,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"I don't know of a JAXB tweak; the way I've done this kind of thing is to implement an XmlEventReader (or XmlStreamReader) that simulates end-of-document when needed.  Note that Unmarshaller.unmarshal() will take one of these as an argument.  To make sure you get the event sequence right, watch a ""normal"" document's event sequence.  You'll do two unmarshal()s.",javax.xml.stream.xmleventreader,javax.xml.stream.xmlstreamreader,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"I don't know of a JAXB tweak; the way I've done this kind of thing is to implement an XmlEventReader (or XmlStreamReader) that simulates end-of-document when needed.  Note that Unmarshaller.unmarshal() will take one of these as an argument.  To make sure you get the event sequence right, watch a ""normal"" document's event sequence.  You'll do two unmarshal()s.",javax.xml.stream.xmleventreader,javax.xml.bind.unmarshaller.unmarshal,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"I don't know of a JAXB tweak; the way I've done this kind of thing is to implement an XmlEventReader (or XmlStreamReader) that simulates end-of-document when needed.  Note that Unmarshaller.unmarshal() will take one of these as an argument.  To make sure you get the event sequence right, watch a ""normal"" document's event sequence.  You'll do two unmarshal()s.",javax.xml.stream.xmlstreamreader,javax.xml.bind.unmarshaller.unmarshal,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"There are a few different things you can do, depending upon how much control you want over the exact color. The easiest way is to change some of the properties in the UIManager to change the colors that Nimbus derives its other colors from. I played around a little with your code, and found that if I put the following code after the call to UIManager.setLookAndFeel(), it would approximate the red-on-black look you attempted in your example:",javax.swing.uimanager,javax.swing.plaf.nimbus.nimbus,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Before, I used the assertEquals() static method from the Assert class of the JUnit framework. This framework is a de-facto standard in writing Java tests and the assertEquals() method family is the standard way to verify the results of your program. They make sure the arguments passed into the method are equal and if they are not, they throw an AssertionError.",org.junit.assert.assertequals,org.junit.assert,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"Before, I used the assertEquals() static method from the Assert class of the JUnit framework. This framework is a de-facto standard in writing Java tests and the assertEquals() method family is the standard way to verify the results of your program. They make sure the arguments passed into the method are equal and if they are not, they throw an AssertionError.",org.junit.assert.assertequals,org.junit.framework.junit,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Before, I used the assertEquals() static method from the Assert class of the JUnit framework. This framework is a de-facto standard in writing Java tests and the assertEquals() method family is the standard way to verify the results of your program. They make sure the arguments passed into the method are equal and if they are not, they throw an AssertionError.",org.junit.assert.assertequals,java.lang.assertionerror,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Before, I used the assertEquals() static method from the Assert class of the JUnit framework. This framework is a de-facto standard in writing Java tests and the assertEquals() method family is the standard way to verify the results of your program. They make sure the arguments passed into the method are equal and if they are not, they throw an AssertionError.",org.junit.assert,org.junit.framework.junit,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Before, I used the assertEquals() static method from the Assert class of the JUnit framework. This framework is a de-facto standard in writing Java tests and the assertEquals() method family is the standard way to verify the results of your program. They make sure the arguments passed into the method are equal and if they are not, they throw an AssertionError.",org.junit.assert,java.lang.assertionerror,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Before, I used the assertEquals() static method from the Assert class of the JUnit framework. This framework is a de-facto standard in writing Java tests and the assertEquals() method family is the standard way to verify the results of your program. They make sure the arguments passed into the method are equal and if they are not, they throw an AssertionError.",org.junit.framework.junit,java.lang.assertionerror,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('no', 'no', 'yes', 'no')]"
"It's only serializable if it extends Serializable or Externalizable and all of its non-static non-transient member variables do so as well, and so on recursively until closure. In this case you clearly have one of type javafx.beans.property.SimpleIntegerProperty, which as the exception tells you isn't serializable:",java.io.serializable,java.io.externalizable,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"It's only serializable if it extends Serializable or Externalizable and all of its non-static non-transient member variables do so as well, and so on recursively until closure. In this case you clearly have one of type javafx.beans.property.SimpleIntegerProperty, which as the exception tells you isn't serializable:",java.io.serializable,javafx.beans.property.simpleintegerproperty,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"It's only serializable if it extends Serializable or Externalizable and all of its non-static non-transient member variables do so as well, and so on recursively until closure. In this case you clearly have one of type javafx.beans.property.SimpleIntegerProperty, which as the exception tells you isn't serializable:",java.io.externalizable,javafx.beans.property.simpleintegerproperty,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.stock,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.stock,java.lang.long,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.stock,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.stock,java.util.date.gettime,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.string,java.util.date.gettime,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.long,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"These constructors are overloaded to call another constructor using this(...). The first no-arg constructor calls the second with null arguments. The second calls a third constructor (not shown), which must take a Stock, String, and long. This pattern, called constructor chaining, is often used to provide multiple ways of instantiating an object without duplicate code. The constructor with fewer arguments fills in the missing arguments with default values, such as with new Date().getTime(), or else just passes nulls.",java.lang.long,java.util.date.gettime,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes')]"
"For reference, the example below overrides the getColumnClass() of DefaultTableModel to obtain the default renderer for types Icon and Date. ",javax.swing.table.defaulttablemodel.getcolumnclass,javax.swing.table.defaulttablemodel,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"For reference, the example below overrides the getColumnClass() of DefaultTableModel to obtain the default renderer for types Icon and Date. ",javax.swing.table.defaulttablemodel.getcolumnclass,javax.swing.icon,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For reference, the example below overrides the getColumnClass() of DefaultTableModel to obtain the default renderer for types Icon and Date. ",javax.swing.table.defaulttablemodel.getcolumnclass,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For reference, the example below overrides the getColumnClass() of DefaultTableModel to obtain the default renderer for types Icon and Date. ",javax.swing.table.defaulttablemodel,javax.swing.icon,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For reference, the example below overrides the getColumnClass() of DefaultTableModel to obtain the default renderer for types Icon and Date. ",javax.swing.table.defaulttablemodel,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"For reference, the example below overrides the getColumnClass() of DefaultTableModel to obtain the default renderer for types Icon and Date. ",javax.swing.icon,java.util.date,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Sending messages directly to the HWND of controls via PostMessage() and SendMessage(), for example to the MalwareBytes Button class, will trigger a button press in the program itself, very similarl to how SetForegroundWindow() should bring an edit-box style control to the front giving you the ability to type. Fun stuff to play with :)",user32.dll.postmessage,user32.dll.sendmessage,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Sending messages directly to the HWND of controls via PostMessage() and SendMessage(), for example to the MalwareBytes Button class, will trigger a button press in the program itself, very similarl to how SetForegroundWindow() should bring an edit-box style control to the front giving you the ability to type. Fun stuff to play with :)",user32.dll.postmessage,user32.dll.setforegroundwindow,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Sending messages directly to the HWND of controls via PostMessage() and SendMessage(), for example to the MalwareBytes Button class, will trigger a button press in the program itself, very similarl to how SetForegroundWindow() should bring an edit-box style control to the front giving you the ability to type. Fun stuff to play with :)",user32.dll.sendmessage,user32.dll.setforegroundwindow,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
This handles Parent#constructor() executed with super() so next you will see code from Son constructor after super() which will generate,parent.constructor,java.lang.object.super,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Further, remember that if you print a string to an output, for example System.out, that will use the system default encoding that is system dependent to convert the String to bytes. It looks like your system default is UTF-8.",java.lang.system.out,java.lang.string,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Further, remember that if you print a string to an output, for example System.out, that will use the system default encoding that is system dependent to convert the String to bytes. It looks like your system default is UTF-8.",java.lang.system.out,java.nio.charset.standardcharsets.utf_8,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"String serverHomeDir = System.getProperty(""server.home.dir"");",java.lang.string,java.lang.system.getproperty,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"No magic here. Just take your data and put it into the zip stream. In my case, I was pulling list/array data, dropping it into a CSV, then putting that CSV in to the zip (as an entry by using zos.putNextEntry(entry);). Both the CSVs and the ZIP are kept as streams so that nothing is written to the filesystem during this operation, and the final result can be just streamed out by the controller. Make sure to close out the entry each time you write one to the zip output stream (zos.closeEntry()).",java.util.zip.zipoutputstream,java.util.zip.zipoutputstream.putnextentry,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"No magic here. Just take your data and put it into the zip stream. In my case, I was pulling list/array data, dropping it into a CSV, then putting that CSV in to the zip (as an entry by using zos.putNextEntry(entry);). Both the CSVs and the ZIP are kept as streams so that nothing is written to the filesystem during this operation, and the final result can be just streamed out by the controller. Make sure to close out the entry each time you write one to the zip output stream (zos.closeEntry()).",java.util.zip.zipoutputstream,java.util.zip.zipoutputstream.closeentry,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"No magic here. Just take your data and put it into the zip stream. In my case, I was pulling list/array data, dropping it into a CSV, then putting that CSV in to the zip (as an entry by using zos.putNextEntry(entry);). Both the CSVs and the ZIP are kept as streams so that nothing is written to the filesystem during this operation, and the final result can be just streamed out by the controller. Make sure to close out the entry each time you write one to the zip output stream (zos.closeEntry()).",java.util.zip.zipoutputstream.putnextentry,java.util.zip.zipoutputstream.closeentry,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
Don't throw an exception unless you really have an exceptional condition. System.exit(int) is there for precisely this reason. Use it.,java.lang.exception,java.lang.system.exit,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Try using Session.getInstance() instead of getDefaultInstance(), which creates a new Session each time, using the supplied properties.",javax.mail.session.getinstance,javax.mail.session,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Try using Session.getInstance() instead of getDefaultInstance(), which creates a new Session each time, using the supplied properties.",javax.mail.session.getinstance,javax.mail.session.getdefaultinstance,"[('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes')]"
"Try using Session.getInstance() instead of getDefaultInstance(), which creates a new Session each time, using the supplied properties.",javax.mail.session,javax.mail.session.getdefaultinstance,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.lang.object.equals,java.util.collection,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.lang.object.equals,java.util.collection.contains.,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.util.list.equals,java.util.collection,"[('no', 'no', 'yes', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.util.list.equals,java.util.collection.contains.,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.util.collection,java.util.linkedlist,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.util.collection,java.util.collection.contains.,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.util.arraylist,java.util.collection.contains.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'no', 'no', 'no')]"
"Although it may be commonly true that many classes have equals() defined so that its objects can only be equal to objects of its own class, that is certainly not always the case. For example, the specification for List.equals() says that two List objects are equal if they are both Lists and have the same contents, even if they are different implementations of List. So coming back to the example in this question, it is possible to have a Collection&lt;ArrayList&gt; and for me to call contains() with a LinkedList as argument, and it might return true if there is a list with the same contents. This would not be possible if contains() were generic and restricted its argument type to E.",java.util.linkedlist,java.util.collection.contains.,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.asyncappender,org.apache.log4j.rolling.externallyrolledfileappender,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.asyncappender,org.apache.log4j.net.socketappender,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.asyncappender,org.apache.log4j.net.telnetappender,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'yes', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.asyncappender,org.apache.log4j.propertyconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.asyncappender,org.apache.log4j.xml.domconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.rolling.externallyrolledfileappender,org.apache.log4j.net.socketappender,"[('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.rolling.externallyrolledfileappender,org.apache.log4j.net.telnetappender,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.rolling.externallyrolledfileappender,org.apache.log4j.propertyconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.rolling.externallyrolledfileappender,org.apache.log4j.xml.domconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'yes', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.net.socketappender,org.apache.log4j.net.telnetappender,"[('no', 'no', 'yes', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.net.socketappender,org.apache.log4j.propertyconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.net.socketappender,org.apache.log4j.xml.domconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.net.telnetappender,org.apache.log4j.propertyconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.net.telnetappender,org.apache.log4j.xml.domconfigurator.configureandwatch,"[('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'no', 'no')]"
"Also I can confirm that it isn't a thread problem within the Log4J logic, because the only time it creates/uses its own thread is when one of AsynchAppender/ExternallyRolledFileAppender/SocketAppender/TelnetAppender is used OR when PropertyConfigurator.configureAndWatch or DOMConfigurator.configureAndWatch method is called.",org.apache.log4j.propertyconfigurator.configureandwatch,org.apache.log4j.xml.domconfigurator.configureandwatch,"[('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'yes', 'yes', 'yes'), ('yes', 'yes', 'yes', 'yes'), ('no', 'no', 'no', 'no'), ('yes', 'no', 'no', 'no'), ('no', 'no', 'no', 'no')]"
"The constructors of Pageable are deprecated, use of() instead:",org.springframework.data.domain.pageable,org.springframework.data.domain.pageable.of,"[('no', 'no', 'no', 'no'), ('yes', 'yes', 'no', 'yes'), ('no', 'no', 'yes', 'no'), ('no', 'no', 'no', 'no'), ('yes', 'yes', 'yes', 'yes'), ('yes', 'yes', 'no', 'yes'), ('yes', 'yes', 'no', 'yes')]"
